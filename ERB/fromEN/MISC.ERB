;/*************************************************************
;System functions
;/*************************************************************

;-------------------------------------------------
;最大幅の定義関数
;-------------------------------------------------
@MAXWIDTH
#FUNCTION
RETURNF STRLENS(DRAWLINESTR)

;-------------------------------------------------
;Shortcut for usual way of handling paging with infinite scroll
;-------------------------------------------------
@PAGE_HANDLE(nCode, nBackPageCode, nCurPage, nFirstPage, nLastPage)
#FUNCTION
#DIM nCode
#DIM nBackPageCode
#DIM nCurPage
#DIM nFirstPage
#DIM nLastPage

RETURNF nCode == nBackPageCode ? ROUND_DECREMENT(nCurPage, nFirstPage, nLastPage) # ROUND_INCREMENT(nCurPage, nFirstPage, nLastPage)

;-------------------------------------------------
;指定範囲内で数値をインクリメントさせる関数
;-------------------------------------------------
@ROUND_INCREMENT(OPERAND, MINVAL, MAXVAL)
#FUNCTION
#DIM OPERAND
#DIM MINVAL
#DIM MAXVAL
OPERAND ++
SIF OPERAND > MAXVAL
	OPERAND = MINVAL

RETURNF OPERAND

;-------------------------------------------------
;指定範囲内で数値をインクリメントさせる関数
;-------------------------------------------------
@ROUND_DECREMENT(OPERAND, MINVAL, MAXVAL)
#FUNCTION
#DIM OPERAND
#DIM MINVAL
#DIM MAXVAL
OPERAND --
SIF OPERAND < MINVAL
	OPERAND = MAXVAL

RETURNF OPERAND

;----------------------------------------------------------
;ARG行になるまでラインを追加
;----------------------------------------------------------
@EQUATE_LINE, ARG
WHILE LINECOUNT < ARG
	PRINTL 
WEND

;-------------------------------------------------
;ARGを(ARG:1 / 100)倍する
;A = MULTIPLY(A, 150)　は　TIMES A, 1.50　と等しい。
;A = MULTIPLY(A, B)　でB <= 0ならば計算結果はマイナスでなくA*1/100とする。
;-------------------------------------------------
@MULTIPLY(ARG, ARG:1)
#FUNCTION
;0以下の数をかけたときには ARG:1 = 1 とする
SIF ARG:1 <= 0
	ARG:1 = 1
LOCAL = ARG * ARG:1 / 100
RETURNF LOCAL

;-------------------------------------------------
;ARGを(100/ARG:1)倍する
;A = DIVIDE(A, 150)　は　TIMES A, 0.66　と大体等しく、A = A * 100 / 150　と等しい
;A = DIVIDE(A, B)　でB <= 0ならば計算結果は無限やマイナスでなくAのままとなる。
;-------------------------------------------------
@DIVIDE(ARG, ARG:1)
#FUNCTION
;0以下の数では割れない
SIF ARG:1 <= 0
	RETURNF ARG
LOCAL = ARG * 100 / ARG:1
RETURNF LOCAL

;---------------------------------------------------------
;10* larger than usable to simulate decimal
;---------------------------------------------------------
;This is to compensate for the engine's tendency to round numbers toward zero.
@ROUND_NEAREST(ARG:0 = 0, ARG:1 = 0)
#FUNCTION
IF ARG:0 == 0
	RETURNF ARG:0
ELSEIF ARG:1 == 1 || ARG:1 == 0
	RETURNF ARG:0
ELSEIF ARG:0 > 0
	RETURNF (ARG:0 + (ARG:1 / 2)) / ARG:1
ELSE
	RETURNF (ARG:0 - (ARG:1 / 2)) / ARG:1
ENDIF

;-------------------------------------------------
;確率判定関数@PERCENT
;式中で使用する関数です。引数％の確率判定を行います。通れば1を返します
;常用する関数ですが、なぜ本体にこれ無いんだろ…。
;-------------------------------------------------
@PERCENT(ARG)
#FUNCTION
RETURNF (ARG - RAND:100) > 0

;-------------------------------------------------
;範囲判定関数@RANGE
;	引数0：対象の数字
;	引数1～2：範囲の上限・下限（逆順可）
;引数0が引数1と引数2の間に収まっていれば1を返します。ともに同値を許容します
;こいつも本体にあっていいと思う。
;-------------------------------------------------
@RANGE(ARG:0, ARG:1, ARG:2)
#FUNCTION
RETURNF INRANGE(ARG:0, MIN(ARG:1, ARG:2), MAX(ARG:1, ARG:2))

;-------------------------------------------------
;dynamically set the padding for text
;-------------------------------------------------
@STRPAD(strIn)
#FUNCTION
#DIMS REF strIn
#DIM DYNAMIC nTextPad
;determine text padding by checking the pending item to show
FOR LOCAL, 0, VARSIZE("strIn")
	SIF STRLENS(strIn:LOCAL) > nTextPad
		nTextPad = STRLENS(strIn:LOCAL)
NEXT
RETURNF nTextPad

;-------------------------------------------------------
;get percent from GvT
;-------------------------------------------------------
@GETPERCENT, ARG:0, ARG:1, ARG:2
#FUNCTION
SIF ARG:0 == 0 || ARG:1 == 0
	RETURNF 0 
SIF ARG:2
	RETURNF ROUND_NEAREST(ARG:0*100, ARG:1)
LOCAL = ARG:0*100 / ARG:1
RETURNF LOCAL

@RESET_PARTS(ARG)
FOR LOCAL, 0, VARSIZE("EXPNAME")
	EXP:ARG:LOCAL = CSVEXP(ARG, LOCAL)
NEXT
FOR LOCAL, 0, VARSIZE("ABLNAME")
	ABL:ARG:LOCAL = CSVABL(ARG, LOCAL)
NEXT
FOR LOCAL, 0, VARSIZE("EXPNAME")
	EXP:ARG:LOCAL = CSVEXP(ARG, LOCAL)
NEXT
TALENT:ARG:걸레 = CSVTALENT(ARG,142)
TALENT:ARG:정조 = CSVTALENT(ARG,30)
TALENT:ARG:성별기호 = CSVTALENT(ARG,81)
TALENT:ARG:무지 = CSVTALENT(ARG,27)

;-------------------------------------------------
;半角でARG:1文字以上ARG文字以下の文字列入力をさせて、RESULTSでかえす
;-------------------------------------------------
@INPUTS_SELECT, ARG, ARG:1
INPUTS
SELECTCASE STRLENS(RESULTS)
CASE IS < ARG:1
	IF STRLENS(RESULTS) == 0
		PRINTL You have to input something.
	ELSE
		PRINTFORML %RESULTS% is too short. You have to input at least {ARG:1} symbols, up to {ARG}.
	ENDIF
	RESTART
CASE IS > ARG
	PRINTFORML %RESULTS% is too long {STRLENS(RESULTS)}/{ARG}.
	RESTART
CASEELSE

ENDSELECT

;-------------------------------------------------
;半角スペースの出力
;-------------------------------------------------
@BL(ARG)
#FUNCTIONS
LOCALS = 
SIF ARG <= 0
	RETURNF LOCALS
LOCALS = %" "*ARG%
RETURNF LOCALS

;-------------------------------------------------
;文字列の桁数を合わせる
;RJは右詰、LJは左詰め
;-------------------------------------------------
@TEXT_RJ(ARGS, ARG)
#FUNCTIONS
SELECTCASE STRLENS(ARGS)
CASE IS >= ARG
	RETURNF ARGS
CASEELSE
	LOCALS = %BL(ARG-STRLENS(ARGS) )%%ARGS%
ENDSELECT
RETURNF LOCALS

@TEXT_LJ(ARGS, ARG)
#FUNCTIONS
SELECTCASE STRLENS(ARGS)
CASE IS >= ARG
	RETURNF ARGS
CASEELSE
	LOCALS = %ARGS%%BL(ARG-STRLENS(ARGS) )%
ENDSELECT
RETURNF LOCALS

@ORDINAL(ARG)
#FUNCTIONS
IF ARG >= 11 && ARG <= 13
    LOCALS = th
ELSE
    SELECTCASE (ARG % 10)
    CASE 1
        LOCALS = st
    CASE 2
        LOCALS = nd
    CASE 3
        LOCALS = rd
    CASEELSE
        LOCALS = th
    ENDSELECT
ENDIF
RETURNF TOSTR(ARG) + LOCALS

;--------------------------------------------------------
;Group the digits for the ease of reading
;Can take any value, uses money by default
;Custom value must be higher than 0, or it will use money
;-------------------------------------------------
@DIGIT_GROUP(ARG)
#FUNCTIONS

RETURNF @"\@(ARG:0 == 0) ? 0 # %TOSTR(ARG:0,"#,###")%\@"


;ARG, who it is
;ARG:1, if it's His/Her or his/her
@HE_SHE(ARG, ARG:1)
#FUNCTIONS
#DIMS OUTPUT
OUTPUT '= @"%TALENT:ARG:성별 == 2?"He"#"She"%"
SIF !ARG:1
	OUTPUT = %TOLOWER(OUTPUT)%
RETURNF OUTPUT

;ARG, who it is
;ARG:1, if it's His/Her or his/her
@HES_SHES(ARG, ARG:1)
#FUNCTIONS
#DIMS OUTPUT
OUTPUT '= @"%TALENT:ARG:성별 == 2?"He's"#"She's"%"
SIF !ARG:1
	OUTPUT = %TOLOWER(OUTPUT)%
RETURNF OUTPUT


;ARG, who it is
;ARG:1, if it's His/Her or his/her
@HIS_HER(ARG, ARG:1)
#FUNCTIONS
#DIMS OUTPUT
OUTPUT '= @"%TALENT:ARG:성별 == 2?"His"#"Her"%"
SIF !ARG:1
	OUTPUT = %TOLOWER(OUTPUT)%
RETURNF OUTPUT

;ARG, who it is
;ARG:1, if it's His/Her or his/her
;ARG:2, force third person (avoids "you"s)
@HIM_HER(ARG, ARG:1, ARG:2)
#FUNCTIONS
#DIMS OUTPUT
;IF !ARG && !THIRD_PERSON && !ARG:2
;	OUTPUT = You
;ELSE
	OUTPUT '= @"%TALENT:ARG:성별 == 2?"Him"#"Her"%"
;ENDIF
SIF !ARG:1
	OUTPUT = %TOLOWER(OUTPUT)%
RETURNF OUTPUT

;ARG, who it is
;ARG:1, if it's His/Her or his/her
;ARG:2, force third person (avoids "you"s)
@HIS_HERS(ARG, ARG:1, ARG:2)
#FUNCTIONS
#DIMS OUTPUT
IF !ARG && !ARG:2
	OUTPUT = Your
ELSE
	OUTPUT '= @"%TALENT:ARG:성별 == 2?"His"#"Hers"%"
ENDIF
SIF !ARG:1
	OUTPUT = %TOLOWER(OUTPUT)%
RETURNF OUTPUT

;ARG, who it is
;ARG:1, if it's Himself/Herself or himself/herself
;ARG:2, force third person (avoids "yourself")
@HIMSELF_HERSELF(ARG, ARG:1, ARG:2)
#FUNCTIONS
#DIMS OUTPUT
OUTPUT '= @"%TALENT:ARG:성별 == 2?"Himself"#"Herself"%"
SIF !ARG:1
	OUTPUT = %TOLOWER(OUTPUT)%
RETURNF OUTPUT

;*************************************************
;Print mutually exclusive terms depending on the condition per function
;Default returning terms defined here can be overridden with _ to define your own
;Example: %PRINT_MALE("man_:breeding sow")%
;Capitalization depends on the case of the arguments
;*************************************************
@PRINT_MALE(ARGS, ARG:0 = -1)
#FUNCTIONS
SIF ARG < 0
	ARG = TARGET
SIF !STRLENS(ARGS)
	ARGS = guy
IF STRFIND(ARGS, "_") >= 0
	ARGS '= REPLACE(ARGS, "_", "")
	GOTO CUSTOM
ENDIF
	
SELECTCASE SPLIT_SINGLE(TOLOWER(ARGS:0))
	CASE "boy"
		LOCALS '= IS_MALE(ARG:0) ? TOLOWER(ARGS:0) # "girl"
	CASE "man"
		LOCALS '= IS_MALE(ARG:0) ? TOLOWER(ARGS:0) # "woman"
	CASE "lad"
		LOCALS '= IS_MALE(ARG:0) ? TOLOWER(ARGS:0) # "lass"
	CASE "guy"
		LOCALS '= IS_MALE(ARG:0) ? TOLOWER(ARGS:0) # "girl"
	CASE "fellow", "fella"
		LOCALS '= IS_MALE(ARG:0) ? TOLOWER(ARGS:0) # "gal"
	CASE "male"
		LOCALS '= IS_MALE(ARG:0) ? TOLOWER(ARGS:0) # "female"
	CASE "mister"
		LOCALS '= IS_MALE(ARG:0) ? TOLOWER(ARGS:0) # "miss"
	CASE "mr."
		LOCALS '= IS_MALE(ARG:0) ? TOLOWER(ARGS:0) # "ms."
	CASE "incubus"
		LOCALS '= IS_MALE(ARG:0) ? TOLOWER(ARGS:0) # "succubus"
	CASE "shota"
		LOCALS '= IS_MALE(ARG:0) ? TOLOWER(ARGS:0) # "loli"
	CASE "son"
		LOCALS '= IS_MALE(ARG:0) ? TOLOWER(ARGS:0) # "daughter"
	CASE "sir"
		LOCALS '= IS_MALE(ARG:0) ? TOLOWER(ARGS:0) # "miss"
	CASE "men"
		LOCALS '= IS_MALE(ARG:0) ? TOLOWER(ARGS:0) # "women"
	CASE "husband"
		LOCALS '= IS_MALE(ARG:0) ? TOLOWER(ARGS:0) # "wife"
	CASE "fiancé", "fiance"
		LOCALS '= IS_MALE(ARG:0) ? "fiancé" # "fiancée"
	CASE "papa"
		LOCALS '= IS_MALE(ARG:0) ? TOLOWER(ARGS:0) # "mama"
CASEELSE
	$CUSTOM
	LOCALS '= IS_MALE(ARG:0) ? SPLIT_SINGLE(TOLOWER(ARGS:0)) # SPLIT_SINGLE(TOLOWER(ARGS:0), 1)
ENDSELECT
RETURNF IS_CAPITALIZED(ARGS:0) ? CAPITALIZE(LOCALS) # LOCALS

;@PRINT_CLIT(ARG = -1)
;#FUNCTIONS
;SIF ARG == -1
;	ARG = TARGET
;SIF HAS_PENIS(ARG)
;	RETURNF FSYN("penis")
;RETURNF SPLIT_G("clitoris:clit")

@PRINT_HASPENIS(ARGS, ARG = -1)
#FUNCTIONS
SIF ARG == -1
	ARG = TARGET
RETURNF RETURN_CAP(ARGS, HAS_PENIS(ARG) ? SPLIT_SINGLE(TOLOWER(ARGS:0)) # SPLIT_SINGLE(TOLOWER(ARGS:0), 1))

;inside:outside
@PRINT_OUTSIDE(ARGS, ARG = -1)
#FUNCTIONS
#DIM nRefPoint
;create point of reference
SIF ARG == -1
	ARG = PLAYER
nRefPoint = INROOM(CFLAG:ARG:현재위치)

SIF !STRLENS(ARGS)
	ARGS = floor
IF STRFIND(ARGS, "_") >= 0
	ARGS '= REPLACE(ARGS, "_", "")
	GOTO CUSTOM
ENDIF
	
SELECTCASE SPLIT_SINGLE(TOLOWER(ARGS:0))
	CASE "floor"
		LOCALS '= nRefPoint ? TOLOWER(ARGS:0) # "ground"
	CASE "bed"
		LOCALS '= nRefPoint ? TOLOWER(ARGS:0) # "ground"
	CASE "room"
		LOCALS '= nRefPoint ? TOLOWER(ARGS:0) # "place"
	CASE "ceiling"
		LOCALS '= nRefPoint ? TOLOWER(ARGS:0) # "sky"
CASEELSE
	$CUSTOM
	LOCALS '= nRefPoint ? SPLIT_SINGLE(TOLOWER(ARGS:0)) # SPLIT_SINGLE(TOLOWER(ARGS:0), 1)
ENDSELECT

RETURNF IS_CAPITALIZED(ARGS:0) ? CAPITALIZE(LOCALS) # LOCALS

@SPLIT_G(ARGS, ARGS:1 = ":")
#FUNCTIONS
#LOCALSSIZE 200

VARSET LOCALS

LOCAL = RESULT

SPLIT ARGS, ARGS:1, LOCALS

LOCAL:1 = RESULT
RESULT = LOCAL

RETURNF LOCALS:(RAND:(LOCAL:1))

;--------------------------------------------------------
;choose only unique non-repeating strings per multiple splits
;in case you want to cram things like "hot and soft", "soft and warm" into one split
;how it works -
;specify the string in the first argument, a string to pad them with in the second argument,
;and amount of times it needs to be output in the third
;for example - SPLIT_M("Fuah:Haah:Fah:Kh:Mmm:Nn:Ah", "...: ", 3) would output
;"Kh... Ah... Fah..." without repeating once, which is equivalent to doing SPLIT_R() three times, except this doesn't repeat
;specify empty space as a split to separate strPad character with spaces
;additionally strPad can be specified with noed command as a split to remove the pad string at the end
;example - SPLIT_M("warm:soft:hot:fuzzy", " and :noed", 2) - "soft and warm", removing " and " at the end
;one thing to watch out for - nCount should never be greater than the split amount, or it will not work due to unique string check
;--------------------------------------------------------
@SPLIT_M(strIn, strPad, nCount)
#FUNCTIONS
#DIM nLoop
#DIM nLoop1
#DIMS strIn
#DIMS DYNAMIC strPad
#DIMS DYNAMIC strTemp, 100
#DIMS DYNAMIC strPrevName, 100
#DIMS DYNAMIC strOutput
#DIM DYNAMIC nCount

SIF STRCOUNT(strIn, ":") + 1 < nCount
	RETURNF "@SPLIT_M has less splits than the amount to output, which will result in an infinite loop (String - " + strIn + "; Amount - " + TOSTR(nCount)

FOR nLoop, 0, nCount
	DO
		;prepare do loop in case of duplicate
		LOCAL = 0
		;generate top part of the name
		strTemp:nLoop '= SPLIT_G(strIn)
		;this thing kinda supposed to make all names unique, ie do not repeat twice within one roll
		FOR nLoop1, 0, nCount
			IF strTemp:nLoop == strPrevName:nLoop1
				LOCAL++
				BREAK
			ENDIF
		NEXT
	LOOP LOCAL
	
	strPrevName:nLoop '= strTemp:nLoop
	
	strOutput = %strOutput%%strTemp:nLoop%%SPLIT_SINGLE(strPad)%\@ SPLIT_CHECK(strPad, " ") && nLoop != nCount-1 ? %BL(1)% # \@
NEXT
;remove the pad symbol at the end if specified
SIF SPLIT_CHECK(strPad, "noed")
	strOutput '= REPLACE(strOutput, SPLIT_SINGLE(strPad) + "$", "")

RETURNF strOutput

;--------------------------------------------------------
;searches and returns a specified part of a split string if any part matches (greedy)
;--------------------------------------------------------
@MATCH_SPLIT(ARGS:0, ARGS:1, ARGS:2 = ":")
#FUNCTIONS
#DIMS DYNAMIC strSplit, 30

SPLIT ARGS:0, ARGS:2, strSplit

FOR LOCAL, 0, RESULT
	SIF STRCOUNT(strSplit:(LOCAL), ARGS:1)
		RETURNF strSplit:(LOCAL)
NEXT

;-------------------------------------------------
;Get Train command num by its name (original japanese name)
;-------------------------------------------------
@TNUM(ARGS)
#FUNCTION
SIF GETNUM(TRAINNAME, ARGS) < 0
	THROW @"Unrecognized TRAINNAME is being specified for TNUM (%ARGS%)"

RETURNF GETNUM(TRAINNAME, ARGS)

;-------------------------------------------------
;Confirm if ARGS equals currently selected Train command (multiple can be specified with / split)
;-------------------------------------------------
@IS_SELECTCOM(ARGS, ARG = 0)
#FUNCTION
#DIM nLoop

SPLIT ARGS, "/", LOCALS, LOCAL
FOR nLoop, 0, LOCAL
	SIF SELECTCOM:ARG == TNUM(LOCALS:nLoop)
		RETURNF SELECTCOM:ARG == TNUM(LOCALS:nLoop)
NEXT

;-------------------------------------------------
;Same as above but for previous command
;-------------------------------------------------
@IS_PREVCOM(ARGS, ARG = 0)
#FUNCTION
#DIM nLoop

SPLIT ARGS, "/", LOCALS, LOCAL
FOR nLoop, 0, LOCAL
	SIF PREVCOM:ARG == TNUM(LOCALS:nLoop)
		RETURNF PREVCOM:ARG == TNUM(LOCALS:nLoop)
NEXT

@IS_COM_SEX(ARGS)
#FUNCTION
IF GROUPMATCH(ARGS, "tflag", "tflagv", "tflaga")
	SIF ARGS == "tflagv" || ARGS == "tflag"
		RETURNF GROUPMATCH(TFLAG:3, 60, 61, 65, 67, 68, 71, 72, 73)
	SIF ARGS == "tflaga" || ARGS == "tflag"
		RETURNF GROUPMATCH(TFLAG:3, 62, 63, 66, 69, 70, 74, 75)
ENDIF

SIF ARGS == "v" || ARGS == ""
	RETURNF IS_SELECTCOM("정상위/후배위/기승위/대면좌위/배면좌위/양구멍삽입/삽입G스팟고문/삽입자궁구고문") || GROUPMATCH(TCVAR:카운터행동, 80, 83, 85)
SIF ARGS == "a" || ARGS == ""
	RETURNF IS_SELECTCOM("정상위애널/후배위애널/기승위애널/대면좌위애널/배면좌위애널/S형결장자극/질내자극") || GROUPMATCH(TCVAR:카운터행동, 87)

;-------------------------------------------------
;末尾に空行ひとつだけを残した状態にする関数
;Function to leave only one blank line at the end
;-------------------------------------------------
@SINGLE_EMPTY_LINE()
WHILE 1
	IF HTML_GETPRINTEDSTR(0) != "<p align='left'><nobr> </nobr></p>"
		PRINTL
		BREAK
	ELSEIF HTML_GETPRINTEDSTR(1) == "<p align='left'><nobr> </nobr></p>"
		CLEARLINE 1
	ELSE
		BREAK
	ENDIF
WEND

;/*************************************************************
;Game related functions
;/*************************************************************
@MUTUAL_KISS(ARG = -1, ARG:1 = 1, ARG:2 = 1)
SIF ARG == -1
	ARG = TARGET
CALL ADD_KISS(ARG, ARG:1, ARG:2)

;title name, takes care of the "the"-part as well
;the titles are unique
;ARG - character ID
;ARG:1 - capital letter at start
;ARG:2 - removes the "the" 

;二つ名に関わるやつ、EN→JP訳が絡んで面倒くさいのでコメントアウト
[SKIPSTART]
@TNAME(ARG, ARG:1 = 0, ARG:2 = 0)
#FUNCTIONS
;if a dialogue uses custom titles, use those instead
IF STRLENS(CUSTOM_TITLE:ARG:CT_TITLES)
	LOCALS:1 = %SPLIT_G(CUSTOM_TITLE:ARG:CT_TITLES)%
	SIF STRCOUNT(LOCALS:1, CUSTOM_TITLE:ARG:CT_EXCLUDED_THE)
		ARG:2 = 1
ELSE
	;grab the title, check against the list of exceptions to exclude "the" if needed
	LOCALS:1 = %SPLIT_G(TITLES(ARG))%
ENDIF
{
SIF GROUPMATCH(LOCALS:1, "One of the Big Four", "Hell's Traffic Accident", "Shuten-Douji of the Gourd Pillow", "Old Youkai #1", "Shoutoku's Prized Steed"
    , "Ibaraki-Douji", "Nega-Kasen", "Arm-chan", "[No Title]", "The Mighty of the Big Four", "The Seventh", "One of the Eight Great Youths")
}
	ARG:2 = 1
;----------------------------
LOCALS = 
IF ARG:1
	LOCALS = The 
ELSE
	LOCALS = the 
ENDIF
IF ARG == RANDOM_CHARANUM
	;might be better to use PRINT_GET_RACE to supplement?
	IF TALENT:ARG:습기선호
		RETURNF @"\@ !ARG:2 ? %LOCALS + " "% # \@Kappa"
	ELSEIF TALENT:ARG:요정
		RETURNF @"\@ !ARG:2 ? %LOCALS + " "% # \@Fairy"
	ELSEIF TALENT:ARG:요괴 == 5
		RETURNF @"\@ !ARG:2 ? %LOCALS + " "% # \@Tengu"
	ELSEIF TALENT:ARG:동물귀 == 2
		RETURNF @"\@ !ARG:2 ? %LOCALS + " "% # \@Rabbit"
	ELSEIF TALENT:ARG:요괴 == 9
		RETURNF @"\@ !ARG:2 ? %LOCALS + " "% # \@%SPLIT_G("Demon:Devil")%"
	ELSEIF TALENT:ARG:요괴 == 2
		RETURNF @"\@ !ARG:2 ? %LOCALS + " "% # \@Oni"
	ELSEIF TALENT:ARG:요호
		RETURNF @"\@ !ARG:2 ? %LOCALS + " "% # \@Kitsune"
	ELSEIF TALENT:ARG:동물귀 == 4
		RETURNF @"\@ !ARG:2 ? %LOCALS + " "% # \@Cat"
	ELSEIF GROUPMATCH(CSTR:ARG:모브코종족, "化け狸", "茨たぬき")
		RETURNF @"\@ !ARG:2 ? %LOCALS + " "% # \@Tanuki"
	ELSEIF TALENT:ARG:유부녀
		RETURNF @"\@ !ARG:2 ? %LOCALS + " "% # \@Woman"
	ELSE
		RETURNF @"\@ !ARG:2 ? %LOCALS + " "% # \@Girl"
	ENDIF
ENDIF
SIF ARG:2
	RETURNF LOCALS:1
RETURNF @"%LOCALS% %LOCALS:1%"

;ARG:0 - which location
;ARG:1 - should it be prefixed with "the ", if appropriate?
;ARG:2 - when adding "the ", should it be "The "?
@NAME_FROM_PLACE_THE(ARG:0, ARG:1 = 1, ARG:2 = 0)
#FUNCTIONS
LOCALS = %NAME_FROM_PLACE(ARG:0)%
SIF ARG:1
	LOCALS = %LOC_THE(ARG:0,ARG:2)%%LOCALS%
RETURNF LOCALS
[SKIPEND]

;changes "the" to "The"
@THE_CASE_SHIFT(ARGS)
#FUNCTIONS
;SUBSTRING ARGS, 0, 1
;IF RESULTS:0 == "t"
;	SUBSTRING ARGS, 1, -1
;	RETURNF @"T%RESULTS%"
;ELSE
	RETURNF ARGS
;ENDIF

;--------------------------------------------------------
;Taken from GrammarAnon's thing in eratohoK
;Inserts line breaks at the last word space of each line for the passed string and returns it.
;nIndent = number of spaces indented (optional)
;strBreakLine = additional thing to print when breaking a line
;nLength = total character width including indent (optional)
;strMatch = character to match after which line break occurs, any space character by default
;CHAR_PER_LINE defined in TRANSLATION.ERH
;Use with PRINTFORM or variants, as the returned string ends in \n
;Should there be non-whitespace characters in excess of specified width, that line will roll over to next and correct formatting will continue at next whitespace
;--------------------------------------------------------
@BREAKENG(strInput, nIndent = 0, strBreakLine = "\n", nLength = 0, strMatch = "\s")
#FUNCTIONS
#DIM LINELENGTH
#DIM nIndent
#DIM nLength
#DIMS strInput
#DIMS strBreakLine
#DIMS strMatch

SIF !nLength
	nLength = MAXWIDTH() - 19
LINELENGTH = nLength - nIndent

IF LINELENGTH < 1
	THROW @BREAKENG Usable length cannot be less than 1, strInput - %strInput%, nIndent - {nIndent}
ELSE
	LOCALS '= REPLACE(strInput, "(.{1," + TOSTR(LINELENGTH) + "})(?:" + strMatch + "|$)", " "*nIndent + "$1" + strBreakLine)
	;remove strBreakLine contents at the end
	RETURNF SUBSTRING(LOCALS, 0, STRLENS(LOCALS) - STRLENS(strBreakLine))
ENDIF

;--------------------------------------------------------
;print dialogue line with linebreaks
;legend: w - wait flag, d - slow type mode with default settings, dc - default color, p - parenthesis mode, t - third person quotes
;--------------------------------------------------------
@PRINT_DIALOGUE, ARGS, ARGS:1
IF SPLIT_CHECK(TOLOWER(ARGS:1), "p")
	LOCALS:0 = （
	LOCALS:1 = ）
ELSEIF SPLIT_CHECK(TOLOWER(ARGS:1), "t")
	LOCALS:0 = 『
	LOCALS:1 = 』
ELSE
	LOCALS:0 = 「
	LOCALS:1 = 」
ENDIF

IF SPLIT_CHECK(TOLOWER(ARGS:1), "d")
	CALL KEYTYPING(BREAKENG(LOCALS:0 + ARGS + LOCALS:1, 0, "\n　", MAXWIDTH() - 19), "l", 1, 2)
ELSEIF SPLIT_CHECK(TOLOWER(ARGS:1), "dc")
	PRINTSDL BREAKENG(LOCALS:0 + ARGS + LOCALS:1, 0, "\n　", MAXWIDTH() - 19)
ELSE
	PRINTSL BREAKENG(LOCALS:0 + ARGS + LOCALS:1, 0, "\n　", MAXWIDTH() - 19)
ENDIF
SIF SPLIT_CHECK(TOLOWER(ARGS:1), "w")
	WAIT
	
;--------------------------------------------------------
;When I want to have BREAKENG applied on the text without moving the entire text into LOCALS first
;First we need to prepare the text by removing line breaks from PRINT instruction
;use this regex PRINT(|FORM)(L|W) (.*) and replace with PRINTFORM $3
;all line breaks will be replaced with <br>, additional line breaks can be inserted the same way
;if there's any kind of WAIT in the text, use that line as the last one and then put WAIT after this function
;colored text is not supported
;--------------------------------------------------------
@PRINT_BREAK(ARGS = "\n", ARGS:1)
#DIMS DYNAMIC PARTS, 100
#DIMS DYNAMIC strFlag, 100
#DIM DYNAMIC nLength
LOCALS '= HTML_TOPLAINTEXT(HTML_POPPRINTINGSTR())
SPLIT LOCALS, "<br>", PARTS

FOR LOCAL, 0, RESULT
	SIF STRLENS(PARTS:LOCAL) == 0
		CONTINUE
		
	VARSET nLength
	;process the flags
	IF STRCOUNT(PARTS:LOCAL, "<wait>")
		PARTS:LOCAL '= REPLACE(PARTS:LOCAL, "<wait>", "")
		strFlag:LOCAL = wait:
	ENDIF
	IF STRCOUNT(PARTS:LOCAL, "<right>")
		PARTS:LOCAL '= REPLACE(PARTS:LOCAL, "<right>", "")
		ALIGNMENT RIGHT
	ENDIF
	;cut a little shorter if there are double-width characters, add on demand
	SIF STRCOUNT(PARTS:LOCAL, "↓|♪")
		nLength = MAXWIDTH()-10
	SIF SPLIT_CHECK(ARGS:1, "br") && LOCAL == 0 ;break line at the beginning
		PRINTL
	IF SPLIT_CHECK(ARGS:1, "dc")
		PRINTSDL BREAKENG(PARTS:LOCAL, , ARGS, nLength)
	ELSEIF SPLIT_CHECK(ARGS:1, "d")
		CALL PRINT_DIALOGUE(PARTS:LOCAL)
	ELSEIF SPLIT_CHECK(ARGS:1, "noLB")
		PRINTS BREAKENG(PARTS:LOCAL, , ARGS, nLength)
	ELSE
		PRINTSL BREAKENG(PARTS:LOCAL, , ARGS, nLength)
	ENDIF
	ALIGNMENT LEFT
	IF SPLIT_CHECK(strFlag:LOCAL, "wait")
		WAIT
	ENDIF
NEXT

SIF SPLIT_CHECK(ARGS:1, "wait") && STRLENS(PARTS:0)
	WAIT

;shorthand instead of remembering the exact code
;@HAS_PENIS(ARG)
;#FUNCTION
;RETURNF (TALENT:ARG:성별 & 2) == 2

;Returns the base form of a verb, driving -> drive
;Always returns lower case
@BASE_FORM(ARGS)
#DIMS BASE_WORD
#FUNCTIONS
BASE_WORD '= ARGS
IF STRCOUNT(ARGS, " ") > 0
	SPLIT ARGS, " ", LOCALS 
	BASE_WORD '= LOCALS:0
ENDIF
;if it ends with -ing
;check special case
;else replace -ing with -e
IF WORD_ENDS_IN(BASE_WORD, "ing")
	SELECTCASE BASE_WORD
		CASE "driving", "forcing"
			BASE_WORD '= REPLACE(BASE_WORD, "ing$", "e")
		CASEELSE
			BASE_WORD '= REPLACE(BASE_WORD, "ing$", "")
	ENDSELECT
ENDIF
RETURNF BASE_WORD

;A replacement for CALLNAME, has flags letting you do certain things
@ANAME(ARG, ONGOING = 0)
#FUNCTIONS
#DIM ONGOING
SIF ONGOING
	RETURNF HIM_HER(ARG)
RETURNF CALLNAME:ARG


;In order to avoid having to write stuff like \@(local:1) == 2?%" "%and the others#\@
@COND_STR(ARGS, CONDITION)
#FUNCTIONS
#DIM CONDITION
IF CONDITION
	RETURNF @"%ARGS%"
ENDIF


@CONJUGATOR(ARGS, ARG:0)
#FUNCTIONS
;IF SPLIT_CHECK(ARGS:0, "ing")
;	LOCALS:0 '= VERBT_CONTINUOUS(SPLIT_SINGLE(ARGS:0), ARG:0)
;ELSEIF SPLIT_CHECK(ARGS:0, "s")
;	LOCALS:0 '= VERBT_SIMPLE(SPLIT_SINGLE(ARGS:0), ARG:0)
;ELSEIF SPLIT_CHECK(ARGS:0, "ed")
;	LOCALS:0 '= VERBT_PAST(SPLIT_SINGLE(ARGS:0))
;ELSE
;	LOCALS:0 '= SPLIT_SINGLE(ARGS:0)
;ENDIF
RETURNF LOCALS

;--------------------------------------------------------
;changes verbs to present continuous tense (ing), not exactly correct on the CVC rule for multi-syllable words
;note this function acts on the first word of the string
;--------------------------------------------------------
@VERBT_CONTINUOUS(ARGS:0, ARG:0 = -1)
#FUNCTIONS
;SIF ARG:0 == -1
;	ARG:0 = THIRD_PERSON
;SIF !ARG:0
;	RETURNF ARGS:0
;;try to affect only first word if sentence is passed
;LOCALS = 
;IF STRCOUNT(ARGS:0, " ") > 0
;	LOCALS:0 '= SPLIT_SINGLE(ARGS:0, 0, " ")
;	LOCALS:1 '= REPLACE(ARGS, SPLIT_SINGLE(ARGS:0, 0, " "), "")
;	ARGS:0 '= LOCALS:0
;ENDIF
;
;IF WORD_ENDS_IN(ARGS:0, "[^aieou][aeiou][^aeiouwxy]") && (!WORD_ENDS_IN(ARGS:0, "er", "en", "o.", "[^p]el") || STRCOUNT(TOLOWER(ARGS:0), "throb|^gel$")) ;complicated to explain... CVC rule for doubling last letter + some exception
;	ARGS:0 = %REPLACE(ARGS:0, "(^[^\s]*[^aieou][aeiou]([^aeiouwxy]))(?=\s|$)", "$1$2ing")%
;ELSEIF WORD_ENDS_IN(ARGS:0, "ie") ;if word ends in "ie", drop and add "ying"
;	ARGS:0 = %REPLACE(ARGS:0, "(^[^\s]+)ie(?=\s|$)", "$1ying")%
;ELSEIF WORD_ENDS_IN(ARGS:0, "[^aeiou]e") ;if word ends in silent "e", drop and add "ing"
;	ARGS:0 = %REPLACE(ARGS:0, "(^[^\s]+[^aeiou])e(?=\s|$)", "$1ing")%
;ELSEIF WORD_ENDS_IN(ARGS:0, "sue") ;try resolving the problem with words like sue, issue, pursue, etc
;	ARGS:0 = %REPLACE(ARGS:0, "(^[^\s]+)e(?=\s|$)", "$1ing")%
;ELSE ;add "ing"
;	ARGS:0 = %REPLACE(ARGS:0, "(^[^\s]+)(?=\s|$)", "$1ing")%
;ENDIF
;SIF STRLENS(LOCALS)
;	ARGS:0 = %ARGS:0%%LOCALS:1%

RETURNF ARGS:0

;--------------------------------------------------------
;Check if first word in string ARGS:0 ends in any specified substring ARGS:1 through ARGS:9
;--------------------------------------------------------
@WORD_ENDS_IN(ARGS:0, ARGS:1 = "NULL", ARGS:2 = "NULL", ARGS:3 = "NULL", ARGS:4 = "NULL", ARGS:5 = "NULL", ARGS:6 = "NULL", ARGS:7 = "NULL", ARGS:8 = "NULL", ARGS:9 = "NULL")
#FUNCTION
RETURNF STRCOUNT(ARGS:0, "^[^\s]*(" + ARGS:1 + "|" + ARGS:2 + "|" + ARGS:3 + "|" + ARGS:4 + "|" + ARGS:5 + "|" + ARGS:6 + "|" + ARGS:7 + "|" + ARGS:8 + "|" + ARGS:9 + ")(?=\s|$)")

;--------------------------------------------------------
;Check if a string ARGS:0 ends in any specified substring ARGS:1 through ARGS:9
;--------------------------------------------------------
@STRING_ENDS_IN(ARGS:0, ARGS:1 = "NULL", ARGS:2 = "NULL", ARGS:3 = "NULL", ARGS:4 = "NULL", ARGS:5 = "NULL", ARGS:6 = "NULL", ARGS:7 = "NULL", ARGS:8 = "NULL", ARGS:9 = "NULL")
#FUNCTION
RETURNF STRCOUNT(ARGS:0, "(" + ARGS:1 + "|" + ARGS:2 + "|" + ARGS:3 + "|" + ARGS:4 + "|" + ARGS:5 + "|" + ARGS:6 + "|" + ARGS:7 + "|" + ARGS:8 + "|" + ARGS:9 + ")$")

;--------------------------------------------------------
;Check if first word in string ARGS:0 starts in any specified substring ARGS:1 through ARGS:9
;--------------------------------------------------------
@WORD_STARTS_IN(ARGS:0, ARGS:1 = "NULL", ARGS:2 = "NULL", ARGS:3 = "NULL", ARGS:4 = "NULL", ARGS:5 = "NULL", ARGS:6 = "NULL", ARGS:7 = "NULL", ARGS:8 = "NULL", ARGS:9 = "NULL")
#FUNCTION

RETURNF STRCOUNT(ARGS:0, "^(" + ARGS:1 + "|" + ARGS:2 + "|" + ARGS:3 + "|" + ARGS:4 + "|" + ARGS:5 + "|" + ARGS:6 + "|" + ARGS:7 + "|" + ARGS:8 + "|" + ARGS:9 + ")")

;--------------------------------------------------------
;Check if a string ARGS:0 starts in any specified substring ARGS:1 through ARGS:9
;--------------------------------------------------------
@STRING_STARTS_IN(ARGS:0, ARGS:1 = "NULL", ARGS:2 = "NULL", ARGS:3 = "NULL", ARGS:4 = "NULL", ARGS:5 = "NULL", ARGS:6 = "NULL", ARGS:7 = "NULL", ARGS:8 = "NULL", ARGS:9 = "NULL")
#FUNCTION

RETURNF STRCOUNT(ARGS:0, "^(" + ARGS:1 + "|" + ARGS:2 + "|" + ARGS:3 + "|" + ARGS:4 + "|" + ARGS:5 + "|" + ARGS:6 + "|" + ARGS:7 + "|" + ARGS:8 + "|" + ARGS:9 + ")")

;--------------------------------------------------------
;changes verbs to 3rd person simple present tense (s)
;note this function acts on the first word of the string
;--------------------------------------------------------
@VERBT_SIMPLE(ARGS:0, ARG:0 = -1)
#FUNCTIONS
;SIF ARG:0 == -1
;	ARG:0 = THIRD_PERSON
;SIF !ARG:0 
;	RETURNF ARGS:0
;IF WORD_ENDS_IN(ARGS:0, "[^aeiou]y") ;if last letter is "y" not preceded by a vowel, drop it and add "ies"
;	ARGS:0 = %REPLACE(ARGS:0, "(^[^\s]+[^aeiou])y(?=\s|$)", "$1ies")%
;ELSEIF WORD_ENDS_IN(ARGS:0, "x", "s", "ch", "sh", "o") ;if word ends in "x", "s", "ss" "sh", "o" for does or "ch" add "es"
;	ARGS:0 = %REPLACE(ARGS:0, "(^[^\s]+)(?=\s|$)", "$1es")%
;ELSE ;add "s"
;	ARGS:0 = %REPLACE(ARGS:0, "(^[^\s]+)(?=\s|$)", "$1s")%
;ENDIF

RETURNF ARGS:0


;--------------------------------------------------------
;A simple check for a noun to see if it's pluralized to return correct word with it
;For example generator functions such as BODYPART can return both breasts and chest
;This function should deal with that
;ARGS:0 takes the word that should be checked, ARGS:1 takes the supporting word
;Example - CHECK_PLNOUN(BODYPART("Chest", CHARA ), "get") - we will return correct form of word "get" depending on whether BODYPART's word ends on "s" or not
;use CHECK_PLVERB for stuff like "is", "has", etc
;--------------------------------------------------------
@CHECK_PLNOUN(ARGS:0, ARGS:1)
#FUNCTIONS

IF !STRCOUNT(ARGS:0,"s$") 
	ARGS:1 = %VERBT_SIMPLE(ARGS:1, 1)%
ENDIF
RETURNF ARGS:0 + " " + ARGS:1

@CHECK_PLVERB(ARGS:0, ARGS:1)
#FUNCTIONS

IF STRCOUNT(ARGS:0,"s$") 
	ARGS:1 = %PLVERB(ARGS:1, 2)%
ENDIF
RETURNF ARGS:0 + " " + ARGS:1

;--------------------------------------------------------
;returns a specified part of a split string
;--------------------------------------------------------
@SPLIT_SINGLE(ARGS:0, ARG:0 = 0, ARGS:1 = ":")
#FUNCTIONS
#DIMS DYNAMIC strSplit, 30

LOCAL = RESULT

SPLIT ARGS:0, ARGS:1, strSplit

RESULT = LOCAL

RETURNF strSplit:(ARG:0)

;--------------------------------------------------------
;modified the function in STR_BODY to be less restrictive (string:string:string, matching string, matching string, etc)
;works similarly to GROUPMATCH, but with : split strings
;--------------------------------------------------------
@SPLIT_CHECK(ARGS:0, ARGS:1 = "NULL", ARGS:2 = "NULL", ARGS:3 = "NULL", ARGS:4 = "NULL", ARGS:5 = "NULL", ARGS:6 = "NULL", ARGS:7 = "NULL", ARGS:8 = "NULL", ARGS:9 = "NULL")
#FUNCTION

RETURNF STRCOUNT(ARGS:0, "(^|:)(" + ARGS:1 + "|" + ARGS:2 + "|" + ARGS:3 + "|" + ARGS:4 + "|" + ARGS:5 + "|" + ARGS:6 + "|" + ARGS:7 + "|" + ARGS:8 + "|" + ARGS:9 + ")($|:)")

;customize the splitter
@SPLIT_CHECK_C(ARGS:0, ARGS:1 = ":", ARGS:2 = "NULL", ARGS:3 = "NULL", ARGS:4 = "NULL", ARGS:5 = "NULL", ARGS:6 = "NULL", ARGS:7 = "NULL", ARGS:8 = "NULL", ARGS:9 = "NULL", ARGS:10 = "NULL")
#FUNCTION

RETURNF STRCOUNT(ARGS:0, "(^|" + "\\" + ARGS:1 + ")(" + ARGS:2 + "|" + ARGS:3 + "|" + ARGS:4 + "|" + ARGS:5 + "|" + ARGS:6 + "|" + ARGS:7 + "|" + ARGS:8 + "|" + ARGS:9 + "|" + ARGS:10 + ")($|" + "\\" + ARGS:1 + ")")

;--------------------------------------------------------
;Pluralizer for NOUNS (pronouns can now be handled in their normal HIS_HER() type functions, see _FUNCTION.ERB for details)
;should cover most irregular nouns that might be used
;removes "a " and "An " from the beginning of nouns
;pluralizes them if ARG:0 > 1
;I'm not going to bother with words ending in O, because most of those are spanish and italian and don't require a rule... unless we're going to start talking about potatoes a lot.
;--------------------------------------------------------
@PLNOUN(ARGS:0, ARG:0, ARG:1)
#FUNCTIONS

;try to affect only last word if sentence is passed
LOCALS =
IF STRLENS(SPLIT_SINGLE(ARGS:0, STRCOUNT(ARGS:0, " "), " "))
	FOR LOCAL, 0, STRCOUNT(ARGS:0, " ")
		LOCALS = %LOCALS + \@ STRLENS(LOCALS) ? %" "%#\@%%SPLIT_SINGLE(ARGS:0, LOCAL, " ")%
	NEXT
	ARGS:0 = %SPLIT_SINGLE(ARGS:0, STRCOUNT(ARGS:0, " "), " ")%
ENDIF

IF ARG:0 > 1
	ARG:1 = IS_CAPITALIZED(ARGS:0)
	ARGS:0 = %TOLOWER(ARGS:0)%
	;remove "a " and "an " at the beginning
	ARGS:0 = %REPLACE(ARGS:0, "^(?:a|an)\s", "")%
	SELECTCASE ARGS:0
	CASE "child"
		ARGS:0 = children
	CASE "foot"
		ARGS:0 = feet
	CASE "it"
		ARGS:0 = them
	CASE "man"
		ARGS:0 = men
	CASE "ovum"
		ARGS:0= ova
	CASE "person"
		ARGS:0 = people
	CASE "that"
		ARGS:0 = those
	CASE "this"
		ARGS:0 = these
	CASE "tooth"
		ARGS:0 = teeth
	CASE "woman"
		ARGS:0 = women
	CASE "themself"
		ARGS:0 = themselves
	CASE "tomato"
		ARGS:0 = tomatoes
	CASEELSE
		IF !WORD_ENDS_IN(ARGS:0, "kai", "ngu", "ami", "ama", "ppa", "jaku") ;many of these Japanese words don't have plural forms
			IF WORD_ENDS_IN(ARGS:0, "[^aeiou]y") ;if last letter is "y" not preceded by a vowel, drop it and add "ies"
				ARGS:0 = %REPLACE(ARGS:0, "(^[^\s]+[^aeiou])y(?=\s|$)", "$1ies")%
			ELSEIF WORD_ENDS_IN(ARGS:0, "[^f]f", "fe") ;if last letter is single "f" or "fe", replace with "ves"
				ARGS:0 = %REPLACE(ARGS:0, "(^[^\s]+)(?:fe|f)(?=\s|$)", "$1ves")%
			ELSEIF WORD_ENDS_IN(ARGS:0, "x", "s", "ch", "sh") ;if word ends in "x", "s", "ss" "sh", or "ch" add "es"
				ARGS:0 = %REPLACE(ARGS:0, "(^[^\s]+)(?=\s|$)", "$1es")%
			ELSE
				ARGS:0 = %REPLACE(ARGS:0, "(^[^\s]+)(?=\s|$)", "$1s")%
			ENDIF
		ENDIF
	ENDSELECT
	SIF ARG:1
		ARGS:0 = %CAPITALIZE(ARGS:0)%
ENDIF

SIF STRLENS(LOCALS)
	ARGS:0 = %LOCALS% %ARGS:0%

RETURNF ARGS:0

;--------------------------------------------------------
;Pluralizer for VERBS (present tense)
;If ARG:0 > 1 pluralizes first word(verb) in ARGS:0, otherwise returns
;This function (and others) modified to only change first word, strings such as "lift up" -> "lifts up" or "carry over" -> "carries over" are acceptable
;--------------------------------------------------------
@PLVERB(ARGS:0, ARG:0)
#FUNCTIONS
	
IF ARG:0 > 1
	SELECTCASE ARGS:0 ;"be" is very irregular
	CASE "is", "are", "be"
		ARGS:0 = are
	CASE "Is", "Are", "Be"
		ARGS:0 = Are
	CASE "was", "were"
		ARGS:0 = were
	CASE "Was", "Were"
		ARGS:0 = Were
	CASE "has", "have"
		ARGS:0 = have
	CASE "Has", "Have"
		ARGS:0 = Have
	CASEELSE
		IF WORD_ENDS_IN(ARGS:0, "(?:ss|x|sh|ch|o)es") ;drop "es", ★Added o for does
			ARGS:0 = %REPLACE(ARGS:0, "(^[^\s]+(?:ss|x|sh|ch|o))es(?=\s|$)", "$1")%
		ELSEIF WORD_ENDS_IN(ARGS:0, "ies") ;replace "ies" with "y"
			ARGS:0 = %REPLACE(ARGS:0, "(^[^\s]+)ies(?=\s|$)", "$1y")%
		ELSE ;drop "s"
			ARGS:0 = %REPLACE(ARGS:0, "(^[^\s]+)s(?=\s|$)", "$1")%
		ENDIF
	ENDSELECT
ENDIF

RETURNF ARGS:0

@CAPITALIZE(ARGS:0)
#FUNCTIONS
RETURNF TOUPPER(SUBSTRING(ARGS:0, 0, 1)) + SUBSTRING(ARGS:0, 1, -1)

;when you need to only uncap the first letter of the sentence and leave the rest
@UNCAPITALIZE(ARGS:0)
#FUNCTIONS
RETURNF TOLOWER(SUBSTRING(ARGS:0, 0, 1)) + SUBSTRING(ARGS:0, 1, -1)

@RAND_CAP(ARGS)
#FUNCTIONS
LOCALS =
LOCAL:0 = RAND:2

FOR LOCAL:1, 0, STRLENS(ARGS)
	IF RAND:3 < LOCAL:0
		LOCALS += @"%TOUPPER(SUBSTRING(ARGS, LOCAL:1, 1))%"
		LOCAL:0 -= 1
	ELSE
		LOCALS += @"%TOLOWER(SUBSTRING(ARGS, LOCAL:1, 1))%"
		LOCAL:0 += 1
	ENDIF
NEXT
RETURNF LOCALS

@CAP_WORD(ARGS)
#FUNCTIONS
LOCALS '= ARGS

LOCALS:1 =
FOR LOCAL, 0, STRCOUNT(LOCALS, " ") + 1
	LOCALS:1 = %CAPITALIZE(LOCALS:1) + \@ STRLENS(LOCALS:1) ? %" "%#\@%%CAPITALIZE(SPLIT_SINGLE(LOCALS, LOCAL, " "))%
NEXT
LOCALS '= LOCALS:1
LOCALS:1 =
FOR LOCAL, 0, STRCOUNT(LOCALS, "-") + 1
	LOCALS:1 = %CAPITALIZE(LOCALS:1) + \@ STRLENS(LOCALS:1) ? %"-"%#\@%%CAPITALIZE(SPLIT_SINGLE(LOCALS, LOCAL, "-"))%
NEXT
LOCALS '= LOCALS:1

RETURNF LOCALS

;-------------------------------------------------
;handle capitalization
;-------------------------------------------------
@CAP_PROCESS(ARGS, ARG)
#FUNCTIONS
SELECTCASE ARG
	CASE 1
		RETURNF TOLOWER(ARGS)
	CASE 2
		RETURNF TOUPPER(ARGS)
	CASE 3
		RETURNF CAPITALIZE(ARGS)
	;random capitalization, courtesy of grammar anon
	CASE 4
		RETURNF RAND_CAP(ARGS)
	;capitalize every word with some limitations
	CASE 5
		RETURNF CAP_WORD(ARGS)
CASEELSE
	RETURNF ARGS
ENDSELECT

;-------------------------------------------------
;return capitalized if received string is capitalized
;-------------------------------------------------
@RETURN_CAP(ARGS, LOCALS)
#FUNCTIONS
RETURNF IS_CAPITALIZED(ARGS:0) ? CAPITALIZE(LOCALS) # LOCALS

@IS_CAPITALIZED(ARGS:0)
#FUNCTION
IF STRCOUNT(ARGS:0,"^[A-Z]")
	RETURNF 1
ELSE
	RETURNF 0
ENDIF


;--------------------------------------------------------
;simply continue last letter of the word
;use ARG to set the size, 0 - random, -1 - disable slur, -2 - slur the vowels, -3 slur last vowel
;--------------------------------------------------------
@SLUR(ARGS, ARG)
#FUNCTIONS
#DIM nRand
ARGS:0 '= SPLIT_G(ARGS:0, ":")
nRand = RAND(2, 6)

SIF ARG == -1 ;multiply none
	RETURNF ARGS
SIF ARG == -2 ;multiply every vowel
	RETURNF replace(ARGS,"(?i)([aeiouy])?", "$1"*nRand)
SIF ARG == -3 ;multiply only last vowel with negative lookahead
	RETURNF replace(ARGS,"(?i)([aeiouy])(?!.*[aeiouy])", "$1"*nRand)
SIF ARG == -4 ;multiply only first vowel
	RETURNF replace(ARGS,"^(.*?)([aeiouy])", "$1" + "$2"*nRand)
;multiply any last character
RETURNF ARGS + SUBSTRING(ARGS, STRLENS(ARGS)-1, -1) * ( ARG > 0 ? ARG # nRand )

;--------------------------------------------------------
;simple stutter
;three types of stutter (actually more) - S-senpai; S...uh/um/erm...senpai; S(, /...)Senpai, we'll check the capitalization for the last type
;--------------------------------------------------------
@STUTTER(ARGS, ARGS:1 = "nospecial")
#FUNCTIONS
;additional adjustment for fucky things
;LOCAL determines at which letter the stuttering starts
IF STRING_STARTS_IN(ARGS, "I'm")
	IF STRLENS(ARGS) > 3
		LOCALS = I%SPLIT_G(", :...:-")%I'm%SUBSTRING(ARGS, 3, -1)%
	ELSE
		LOCALS = I%SPLIT_G(", :...:-")%I am
	ENDIF
	RETURNF LOCALS
ELSEIF STRING_STARTS_IN(ARGS, "I ") && STRLENS(ARGS) > 1
	RETURNF @"I%SPLIT_G(", :...:-")%I%SUBSTRING(ARGS, 1, -1)%"
ELSEIF STRING_STARTS_IN(ARGS, "I") && STRLENS(ARGS) == 1
	RETURNF @"I%SPLIT_G(", :...:-")%I"
ELSE
	LOCAL = RAND:2 + 1
ENDIF
		
LOCALS = %SUBSTRING(ARGS, 0, STRLENS(ARGS) >= 5 ? LOCAL # 1)%
VARSET LOCAL
IF !SPLIT_CHECK(ARGS:1, "nospecial") && (SPLIT_CHECK(ARGS:1, "special") || RAND:3)
	IF SPLIT_CHECK(ARGS:1, "shy") || (!RAND:3 && STRLENS(ARGS) >= 5 && !SPLIT_CHECK(ARGS:1, "noshy"))
		LOCALS = %LOCALS%...%SPLIT_G("uh:um:erm:er")%...
		LOCAL:1 ++
	ELSE
		LOCALS = %LOCALS%-
	ENDIF
	IF SPLIT_CHECK(ARGS:1, "ss") || (RAND:3 && !LOCAL:1 && !SPLIT_CHECK(ARGS:1, "noss")) ;super stutter
		LOCAL:2 = RAND:2 + 1
		SIF LOCAL:2 < LOCAL
			LOCAL:2 = LOCAL
		LOCALS = %LOCALS%%@"%SUBSTRING(ARGS, 0, STRLENS(ARGS) >= 5 ? LOCAL:2 # 1)%-"*(RAND:2+1)%
	ENDIF
		
	LOCALS = %LOCALS%%ARGS%
ELSE
	LOCALS = %LOCALS%%SPLIT_G(", :...:-")%%ARGS%
ENDIF
;RETURNF SUBSTRING(ARGS, 0, STRLENS(ARGS) >= 5 ? RAND:2 + 1 # 1) + ( RAND:3 ? (!RAND:3 && STRLENS(ARGS) >= 5 ? @"...%SPLIT_G("uh:um:erm:er")%..." # "-") + (RAND:3 ? (SUBSTRING(ARGS, 0, STRLENS(ARGS) >= 5 ? RAND:2 + 1 # 1) + "-")*(RAND:2+1) # "") + TOLOWER(ARGS) # SPLIT_G(", :...") + ( IS_CAPITALIZED(ARGS) ? CAPITALIZE(ARGS) # ARGS ) )

RETURNF LOCALS

;--------------------------------------------------------
;divide the word with a symbol
;ARGS:1 for the divider, - is by default
;if ARGS:1 is more than one symbol in length, the length of division will increase
;--------------------------------------------------------
@DIVIDER(ARGS, ARGS:1)
#FUNCTIONS
SIF ARGS:1 == ""
	ARGS:1 = -

FOR LOCAL, 0, STRLENS(ARGS)
	SIF STRLENS(ARGS) <= (1 + (STRLENS(ARGS:1) - 1)) + LOCAL * (2 * STRLENS(ARGS:1))
		BREAK
	ARGS = %SUBSTRING(ARGS, 0, (1 + (STRLENS(ARGS:1) - 1)) + LOCAL * (2 * STRLENS(ARGS:1)) )%%ARGS:1%%SUBSTRING(ARGS, (1 + (STRLENS(ARGS:1) - 1)) + LOCAL * (2 * STRLENS(ARGS:1)), -1)%
NEXT

RETURNF ARGS

;-------------------------------------------------
;Make a start of a section (non-button)
;-------------------------------------------------
@PRINTLINE, ARGS, ARGS:1 = "-"
PRINTFORML □ %ARGS:0% □%ARGS:1*(138-STRLENS(ARGS))%


@PALAM_NUM(ARG, ARG:1)
#FUNCTIONS
;999999を超えたらkMGTP
;Emueraではペタ程度（64ビット）まで扱えるとのこと
VARSET LOCALS
FOR LOCAL, 0, 5
	SIF ARG < 1000000
		BREAK
	SELECTCASE LOCAL
	CASE 0
		LOCALS = k
	CASE 1
		LOCALS = M
	CASE 2
		LOCALS = G
	CASE 3
		LOCALS = T
	CASE 4
		LOCALS = P
	ENDSELECT
	ARG /= 1000
NEXT
;数値の桁数に応じて間隔を調整
IF STRLENS(LOCALS)
	LOCALS = {ARG, ARG:1 ? 0 # 5}%LOCALS%
ELSE
	LOCALS = {ARG, ARG:1 ? 0 # 6}
ENDIF

RETURNF LOCALS


;-------------------------------------------------
;Counting numbers and positions
;this is pretty much copypaste from LT, thanks inno
;Only works for values -99,999 to 99,999
;args:
;num for simple int to string (3 - three, 14 - fourteen, 99 - ninety nine, etc)
;pos for positions (1 - first, 13 - thirteenth, 42 - forty second, etc)
;ARG:1 is the additional capitalization flag, 1 - capitalize only first word, 2 - capitalize every word
;-------------------------------------------------
@NUM_COUNT(ARG, ARGS = "num", ARG:1)
#FUNCTIONS
;LOCALS =
;
;IF ARG < 0
;	LOCALS '= "minus "
;ENDIF
;ARG = ABS(ARG)
;SIF ARG >= 100000
;	RETURNF LOCALS + "a lot"
;
;IF ARG >= 1000
;	IF ARG/1000 < 20
;		LOCALS += nCountUnderTwenty:(ARG/1000) + " thousand"
;	ELSE
;		LOCALS += nCountTens:(ARG/10000) + ( (ARG/1000)%10 != 0 ? "-" + nCountUnderTwenty:((ARG/1000)%10) # "") + " thousand"
;	ENDIF
;ENDIF
;
;IF ARG >= 100 
;	;IF ARG >= 1000 && ARG % 1000 != 0
;	;	LOCALS += ", "
;	;ENDIF
;	IF ARG >= 1000 && ARG % 1000 != 0
;		IF ARG*10%10000 % 1000 == 0
;			LOCALS += " and "
;		ELSEIF ARG*10%10000 > 1000
;			LOCALS += ", "
;		ENDIF
;	ENDIF
;
;	ARG = ARG % 1000
;	IF ( !STRLENS(LOCALS) || ARG >= 100) 
;		LOCALS += nCountUnderTwenty:(ARG/100) + " hundred"
;	ENDIF
;	IF ARG % 100 != 0
;		LOCALS += " and "
;		ARG = ARG % 100
;	ELSEIF ARGS != "num"
;		LOCALS += "th"
;	ENDIF
;ENDIF
;
;IF (ARG % 100) < 20
;	IF (ARG%100 == 0)
;		IF !STRLENS(LOCALS)
;			RETURNF "zero"
;		ENDIF
;	ELSE
;		LOCALS += (ARGS == "num" ? nCountUnderTwenty:(ARG%100) # nCountPosUnderTwenty:(ARG%100) )
;	ENDIF
;ELSEIF ARG % 10 == 0 && ARGS != "num"
;	LOCALS += nCountPosTens:((ARG%100)/10)
;ELSE
;	LOCALS += nCountTens:((ARG%100)/10) + ( (ARG%10!=0) ? "-"+(ARGS == "num" ? nCountUnderTwenty:(ARG%10) # nCountPosUnderTwenty:(ARG%10) )# "")
;ENDIF
;
;SELECTCASE ARG:1
;	CASE 1
;		LOCALS '= CAPITALIZE(LOCALS)
;	CASE 2
;		LOCALS:1 =
;		FOR LOCAL, 0, STRCOUNT(LOCALS, " ") + 1
;			LOCALS:1 = %CAPITALIZE(LOCALS:1) + \@ STRLENS(LOCALS:1) ? %" "%#\@%%CAPITALIZE(SPLIT_SINGLE(LOCALS, LOCAL, " "))%
;		NEXT
;		LOCALS '= LOCALS:1
;		LOCALS:1 =
;		FOR LOCAL, 0, STRCOUNT(LOCALS, "-") + 1
;			LOCALS:1 = %CAPITALIZE(LOCALS:1) + \@ STRLENS(LOCALS:1) ? %"-"%#\@%%CAPITALIZE(SPLIT_SINGLE(LOCALS, LOCAL, "-"))%
;		NEXT
;		;lower.replace(/\b(\w)/g, c => c.toUpperCase());
;		LOCALS '= LOCALS:1
;ENDSELECT
RETURNF LOCALS

;--------------------------------------------------------
;pluralize the word if ARG is more than 1
;--------------------------------------------------------
@PLURALIZER(ARGS, ARG)
#FUNCTIONS
SIF ARG > 1 || ARG == 0
	ARGS = %PLNOUN(ARGS, 2)%
RETURNF ARGS

;same, but for outputting the value and the word at the same time
@PRINT_PLUR(ARGS, ARG)
#FUNCTIONS
RETURNF TOSTR(ARG) + " " + PLURALIZER(ARGS, ARG)

;--------------------------------------------------------
;a simple check for an article
;--------------------------------------------------------
@ARTICLE(ARGS:0)
#FUNCTIONS
SUBSTRING ARGS, 0, 1
SIF RESULTS == "【"
	RETURNF ARGS:0
;exceptions, add on demand
SIF STRCOUNT(ARGS:0,"(?i)^uni|^usa|^one")
	RETURNF "a " + ARGS:0

IF STRCOUNT(ARGS:0,"(?i)^[aeiouy]")
	ARGS:0 = %"an " + ARGS:0%
ELSE
	ARGS:0 = %"a " + ARGS:0%
ENDIF
RETURNF ARGS:0

@TWENTY_FOUR_TIME(ARG)
#FUNCTIONS
#DIMS HOURS
#DIMS MINUTES
HOURS '= @"{ARG / 60}"
SIF ARG / 60 < 10
	HOURS '= @"0%HOURS%"
MINUTES '= @"{ARG % 60}"
IF ARG % 60 == 0
	MINUTES = 00
ELSEIF ARG % 60 < 10
	MINUTES '= @"0%MINUTES%"
ENDIF
RETURNF @"%HOURS%:%MINUTES%"

@COUNT_CORRECT(ARG = 0, ARG:1 = 0, ARG:2 = 0, ARG:3 = 0, ARG:4 = 0, ARG:5 = 0, ARG:6 = 0)
#FUNCTION
LOCAL = 0
FOR LOCAL:1, 0, 7
	SIF ARG:(LOCAL:1)
		LOCAL ++
NEXT
RETURNF LOCAL

;Makes it easier to make run-on sentences
@ENGLISH_GRAMMAR_BUILDING(WHO, MODE = 0, ARGS, ARG, ARGS:1, ARG:1, ARGS:2 = "", ARG:2, ARGS:3 = "", ARG:3,ARGS:4 ="", ARG:4,ARGS:5 ="", ARG:5,ARGS:6 ="", ARG:6)
#DIM WHO
#DIM MODE
#DIMS CONNECTOR


SIF ARG
	PRINTFORM %ARGS%
SIF ARG && COUNT_CORRECT(ARG:1, ARG:2, ARG:3, ARG:4, ARG:5, ARG:6) == 1
	PRINTFORM  and 
SIF ARG && COUNT_CORRECT(ARG:1, ARG:2, ARG:3, ARG:4, ARG:5, ARG:6) > 1
	PRINTFORM , 

SIF ARG:1
	PRINTFORM %ARGS:1%
IF ARG:1 && COUNT_CORRECT(ARG) == 1 && COUNT_CORRECT(ARG:2, ARG:3, ARG:4, ARG:5, ARG:6) == 1
	PRINTFORM , and 
ELSEIF ARG:1 && COUNT_CORRECT(ARG:2, ARG:3, ARG:4, ARG:5, ARG:6) == 1
	PRINTFORM  and 
ELSEIF ARG:1 && COUNT_CORRECT(ARG:2, ARG:3, ARG:4, ARG:5, ARG:6) > 1
	PRINTFORM , 
ENDIF

SIF ARG:2
	PRINTFORM %ARGS:2%
IF ARG:2 && COUNT_CORRECT(ARG, ARG:1) && COUNT_CORRECT(ARG:3, ARG:4, ARG:5, ARG:6) == 1
	PRINTFORM , and 
ELSEIF ARG:2 && COUNT_CORRECT(ARG:3, ARG:4, ARG:5, ARG:6) == 1
	PRINTFORM  and 
ELSEIF ARG:2 && COUNT_CORRECT(ARG:3, ARG:4, ARG:5, ARG:6) > 1
	PRINTFORM , 
ENDIF

SIF ARG:3
	PRINTFORM %ARGS:3%
IF ARG:3 && COUNT_CORRECT(ARG, ARG:1, ARG:2) && COUNT_CORRECT(ARG:4, ARG:5, ARG:6) == 1
	PRINTFORM , and 
ELSEIF ARG:3 && COUNT_CORRECT(ARG:4, ARG:5, ARG:6) == 1
	PRINTFORM  and 
ELSEIF ARG:3 && COUNT_CORRECT(ARG:4, ARG:5, ARG:6) > 1
	PRINTFORM , 
ENDIF

SIF ARG:4
	PRINTFORM %ARGS:4%
IF ARG:4 && COUNT_CORRECT(ARG, ARG:1, ARG:2, ARG:3) && COUNT_CORRECT(ARG:5, ARG:6) == 1
	PRINTFORM , and 
ELSEIF ARG:4 && COUNT_CORRECT(ARG:5, ARG:6) == 1
	PRINTFORM  and 
ELSEIF ARG:4 && COUNT_CORRECT(ARG:5, ARG:6) > 1
	PRINTFORM , 
ENDIF

SIF ARG:5
	PRINTFORM %ARGS:5%
IF ARG:5 && COUNT_CORRECT(ARG, ARG:1, ARG:2, ARG:3) && COUNT_CORRECT( ARG:6) == 1
	PRINTFORM , and 
ELSEIF ARG:5 && COUNT_CORRECT( ARG:6) == 1
	PRINTFORM  and 
ENDIF

SIF ARG:6
	PRINTFORM %ARGS:6%

;----------------------------------------------------------------------
;Create a list in a string, e.g: "X, Y and Z"
;Pass a string with the list here and it will do it for you
;Stuff in string should be listed with comma like %", "%
;Modded to it uses full-width commas, i.e. "、"
;Added option to adjust the last connector, enabling the use of " or" instead of " and" 
;----------------------------------------------------------------------
@LIST_IN_STRING(ARGS, strSplit = "、", strLast = " and")
#FUNCTIONS
#DIMS strSplit
#DIMS strLast
;add spaces
ARGS '= REPLACE(ARGS, strSplit, strSplit + " ")
;clear off the last part
ARGS '= REPLACE(ARGS, strSplit + " $", "")
;use negative lookahead to replace comma before the last item with "AND"
ARGS '= REPLACE(ARGS, "(" + strSplit + ")(?!.*" + strSplit + ")", strLast)
;finally place commas in case splitter wasn't a comma
ARGS '= REPLACE(ARGS, strSplit, ",")

RETURNF ARGS

;Children are not people
@HE_SHE_CHILD(ARG,ARG:1, CHILDNUM)
#FUNCTIONS
#DIM CHILDNUM
#DIMS OUTPUT
OUTPUT '= @"%CHILD_SEX:ARG:CHILDNUM == 1?"She"#"He"%"
SIF !ARG:1
	OUTPUT = %TOLOWER(OUTPUT)%
RETURNF OUTPUT

@HIM_HER_CHILD(ARG,ARG:1,CHILDNUM)
#FUNCTIONS
#DIM CHILDNUM
#DIMS OUTPUT
OUTPUT '= @"%CHILD_SEX:ARG:CHILDNUM == 1?"Her"#"Him"%"
SIF !ARG:1
	OUTPUT = %TOLOWER(OUTPUT)%
RETURNF OUTPUT

@HIS_HER_CHILD(ARG,ARG:1,CHILDNUM)
#FUNCTIONS
#DIM CHILDNUM
#DIMS OUTPUT
OUTPUT '= @"%CHILD_SEX:ARG:CHILDNUM == 1?"Her"#"His"%"
SIF !ARG:1
	OUTPUT = %TOLOWER(OUTPUT)%
RETURNF OUTPUT

@HIS_HERS_CHILD(ARG,ARG:1,CHILDNUM)
#FUNCTIONS
#DIM CHILDNUM
#DIMS OUTPUT
OUTPUT '= @"%CHILD_SEX:ARG:CHILDNUM == 1?"Hers"#"His"%"
SIF !ARG:1
	OUTPUT = %TOLOWER(OUTPUT)%
RETURNF OUTPUT

@HIMSELF_HERSELF_CHILD(ARG,ARG:1,CHILDNUM)
#FUNCTIONS
#DIM CHILDNUM
#DIMS OUTPUT
OUTPUT '= @"%CHILD_SEX:ARG:CHILDNUM == 1?"Herself"#"Himself"%"
SIF !ARG:1
	OUTPUT = %TOLOWER(OUTPUT)%
RETURNF OUTPUT

@BOY_GIRL_CHILD(ARG,ARG:1, CHILDNUM)
#FUNCTIONS
#DIM CHILDNUM
#DIMS OUTPUT
OUTPUT '= @"%CHILD_SEX:ARG:CHILDNUM == 1?"Girl"#"Boy"%"
SIF !ARG:1
	OUTPUT = %TOLOWER(OUTPUT)%
RETURNF OUTPUT

@SON_DAUGHTER_CHILD(ARG,ARG:1, CHILDNUM)
#FUNCTIONS
#DIM CHILDNUM
#DIMS OUTPUT
OUTPUT '= @"%CHILD_SEX:ARG:CHILDNUM == 1?"Daughter"#"Son"%"
SIF !ARG:1
	OUTPUT = %TOLOWER(OUTPUT)%
RETURNF OUTPUT

;*************************************************
;Convenient checking functions
;*************************************************

;-------------------------------------------------
;ARG:0番のキャラにＶがあるかどうかを返す関数
;reminder: getbit TALENT:ARG:성별, 0 <- has vagina (futa, female), 1 <- has penis (male, futa)
;again shithead (me): 성별 = 1 - female, 성별 = 2 - male, 성별 = 3 - futa
;-------------------------------------------------
@HAS_VAGINA(ARG:0)
#FUNCTION
RETURNF GETBIT(TALENT:ARG:성별, 0)

@IS_VIRGIN(ARG:0)
#FUNCTION
RETURNF TALENT:(ARG:0):처녀

;-------------------------------------------------
;ARG:0番のキャラがベースとして男扱いなら1を返す関数
;-------------------------------------------------
@IS_MALE(ARG:0)
#FUNCTION
RETURNF TALENT:ARG:성별 == 2

@IS_DOUTEI(ARG:0)
#FUNCTION
RETURNF !TALENT:ARG:비동정 && HAS_PENIS(ARG)

;-------------------------------------------------
;ARG:0番のキャラがベースとして女扱いなら1を返す関数
;-------------------------------------------------
@IS_FEMALE(ARG:0)
#FUNCTION
RETURNF !IS_MALE(ARG:0)

@IS_FUTA(ARG:0)
#FUNCTION
RETURNF TALENT:ARG:성별 == 3

;-------------------------------------------------
;ARG:0番のキャラとARG:1番のキャラが同性かどうかを返す関数
;-------------------------------------------------
@IS_SAMESEX(ARG:0, ARG:1)
#FUNCTION
RETURNF IS_MALE(ARG:0) == IS_MALE(ARG:1)

;-------------------------------------------------
;キャラARG:0のバストサイズを数値に変換する
;-2:絶壁～2:爆乳
;-------------------------------------------------
@GET_BUSTSIZE(ARG:0)
#FUNCTION
SIF IS_MALE(ARG:0)
	RETURNF -2

RETURNF TALENT:ARG:가슴사이즈

;FileName_COMMON.ERB ------------------------------- Rev1.01
;TARGET性格強度判定
;CALL		USER
;ARG		ターゲットNO
;RETURN		性格強度（＋強気, －弱気）
;COMMENT	+3以上で強気、-1以下で弱気くらいかな
;-----------------------------------------------------------
@CHARA_DISPOS(T_NO)
#FUNCTION
#DIM T_NO
LOCAL = 0
FOR LOCAL:1,10,30
	SIF TALENT:T_NO:(LOCAL:1) == 0
		CONTINUE
	SELECTCASE LOCAL:1
		;Skip
		CASE 20,25
			;Do Nothing
		;Boolean_Talent_True
		CASE 26
			LOCAL += TALENT:T_NO:(LOCAL:1)
		;Boolean_Talent_False
		CASE 21,22
			LOCAL -= TALENT:T_NO:(LOCAL:1)
		;Else_Talent
		CASEELSE
			LOCAL += TALENT:T_NO:(LOCAL:1)
	ENDSELECT
NEXT
RETURNF LOCAL

;-------------------------------------------------
;check if character ARG:0 has childish properties
;by default check both mind and body, where mind is just an infantile and body is just a midget (perfectly legal officer I swear on me mum)
;-------------------------------------------------
@IS_CHILD(ARG:0, ARGS:0)
#FUNCTION
SELECTCASE ARGS
	CASE "age"
		RETURNF TALENT:(ARG:0):연령 < 0
	CASE "mind"
		RETURNF TALENT:(ARG:0):유치
	CASE "body"
		RETURNF GROUPMATCH(TALENT:(ARG:0):체형, -1, -2)
CASEELSE
	RETURNF (TALENT:(ARG:0):연령 < 0 || (TALENT:(ARG:0):유치 && TALENT:(ARG:0):연령 < 1)) && GROUPMATCH(TALENT:(ARG:0):체형, -1, -2)
ENDSELECT

@IS_SPERMARCHE(ARG)
#FUNCTION
RETURNF HAS_PENIS(ARG) && ( !IS_CHILD(ARG) || (IS_CHILD(ARG) && !IS_DOUTEI(ARG)) )

;A more complete semen description
;Does not work when the player is completely alone, has to have two characters as input
;ARG - whose semen it is
;ARG:1 - who the "target" is
@SAMEN_DESCRIPTION_FULL(ARG,ARG:1)
#FUNCTIONS
VARSET LOCALS

@IS_ARE_PANTIES(ARGS)
#FUNCTIONS
IF PLURAL_PANTIES(ARGS)
	RETURNF "are"
ELSE
	RETURNF "is"
ENDIF

@IT_THEM_PANTIES(ARGS)
#FUNCTIONS
IF PLURAL_PANTIES(ARGS)
	RETURNF "them"
ELSE
	RETURNF "it"
ENDIF

@IT_THEY_PANTIES(ARGS)
#FUNCTIONS
IF PLURAL_PANTIES(ARGS)
	RETURNF "they"
ELSE
	RETURNF "it"
ENDIF

@HAS_HAVE_PANTIES(ARGS)
#FUNCTIONS
IF PLURAL_PANTIES(ARGS)
	RETURNF "have"
ELSE
	RETURNF "has"
ENDIF

@THIS_THESE_PANTIES(ARGS)
#FUNCTIONS
IF PLURAL_PANTIES(ARGS)
	RETURNF "these"
ELSE
	RETURNF "this"
ENDIF

@ARTICLE_PANTIES(ARGS)
#FUNCTIONS
IF PLURAL_PANTIES(ARGS)
	RETURNF ARGS
ELSE
	RETURNF ARTICLE(ARGS)
ENDIF

@PLURAL_PANTIES(ARGS)
#FUNCTION
RETURNF STRCOUNT(TOLOWER(ARGS), "bloomers|boxers|trunks|panties|scanties|drawers|spats|underpants|knickers")


;-------------------------------------------------
;特殊な書式の文字列ARGSを読める文章に直す
;行や命令は_で区切る事。そしてLOCALSは99までなので手加減してくれ
;CASEを増やして、そのうち文字列を別作成しないで済むようにしたい
;FLAG:5で操作することができる。
;0bit WAITを打ち消し、WをPRINTLに変換する
;-------------------------------------------------
@PRINT_STR, ARGS, ARGS:1, ARGS:2, ARGS:3, ARGS:4, ARGS:5, ARGS:6, ARGS:7, ARGS:8, ARGS:9
#DIM LCOUNT
#DIM nInitColor
#DIMS TEMP, 5
#LOCALSSIZE 100
FOR LCOUNT, 1, 10
	SIF ARGS:LCOUNT != ""
		ARGS = %ARGS%@%ARGS:LCOUNT%
NEXT

nInitColor = GETCOLOR()

VARSET LOCALS

;compatibility
;ARGS '= REPLACE(ARGS, "_", "@")

;文字列を分解する
SPLIT ARGS, "@", LOCALS

FOR LCOUNT, 0, RESULT
	;特殊な操作
	SELECTCASE LOCALS:LCOUNT
	;CASE ""
	;	BREAK
	CASE "CALLNAME:TARGET"
		PRINTFORM %CALLNAME:TARGET%
		CONTINUE
	CASE "CALLNAME:PLAYER"
		PRINTFORM %CALLNAME:PLAYER%
		CONTINUE
	CASE "CALLNAME:ASSI"
		PRINTFORM %CALLNAME:ASSI%
		CONTINUE
	CASE "CALLNAME:MASTER"
		PRINTFORM %CALLNAME:MASTER%
		CONTINUE
	CASE "BUTTON"
		;次の文字をボタンにする
		LCOUNT += 1
		PRINTBUTTON LOCALS:LCOUNT, LOCALS:LCOUNT
		SETCOLOR nInitColor
		FONTREGULAR
		CONTINUE
	;create a button that can be custom set
	CASE "BUTTONS"
		;次の文字をボタンにする
		LCOUNT += 1
		SPLIT LOCALS:LCOUNT, "|", TEMP
		PRINTBUTTON TEMP:0, TEMP:1
		SETCOLOR nInitColor
		FONTREGULAR
		CONTINUE
	CASE "BUTTONNUM"
		;次の文字をボタンにする
		LCOUNT += 1
		SPLIT LOCALS:LCOUNT, "|", TEMP
		PRINTBUTTON TEMP:0, TOINT(TEMP:1)
		SETCOLOR nInitColor
		FONTREGULAR
		CONTINUE
	CASE "NOBUTTON"
		;次の文字をボタンにしない
		LCOUNT += 1
		PRINTPLAINFORM %LOCALS:LCOUNT%
		SETCOLOR nInitColor
		FONTREGULAR
		CONTINUE
	CASE "-"
		;次の文字に打消し線を引く
		FONTSTYLE 4
		CONTINUE
	CASE "L"
		PRINTL 
		CONTINUE
	CASE "W"
		;IF GETBIT(FLAG:PRINT_STR操作, 0)
		;	PRINTL 
		;ELSE
			PRINTW 
		;ENDIF 
		CONTINUE
	CASE "WAIT"
		;SIF GETBIT(FLAG:PRINT_STR操作, 0) == 0
			WAIT
		CONTINUE
	CASE "FORCEWAIT"
		FORCEWAIT
		CONTINUE
	CASE "H", "HEART"
		CALL HEARTMARK
		CONTINUE
	;CASE "WH"
	;	CALL WHITE_HEARTMARK
	;	CONTINUE
	;CASE "BH"
	;	CALL BIG_HEARTMARK
	;	CONTINUE
	;CASE "HH"
	;	SETCOLOR C_HEARTPINK;DEF_COLOR("ハートピンク")
	;	CALL HEARTMARK
	;	CONTINUE
	;CASE "BHH"
	;	SETCOLOR C_HEARTPINK;DEF_COLOR("ハートピンク")
	;	CALL BIG_HEARTMARK
	;	CONTINUE
	CASE "／／／"
		SETCOLOR C_PINK2;DEF_COLOR("핑크")
		PRINT ///
		SETCOLOR nInitColor
		CONTINUE
	CASE "RGB"
		LCOUNT += 1
		SPLIT LOCALS:LCOUNT, "//", TEMP
		SETCOLOR TOINT(TEMP:0), TOINT(TEMP:1), TOINT(TEMP:2)
		CONTINUE
	CASE "HEX"
		LCOUNT += 1
		SETCOLOR TOINT(LOCALS:LCOUNT)
		CONTINUE
	;CASE "ショッキングピンク", "핑크", "ハートピンク", "빨강빛", "紅", "黄色", "暗黄色", "イエロー", "초록빛", "푸른빛", "水色", "暗灰色", "灰色", "明灰色", "흰빛"
	;	SETCOLOR DEF_COLOR(LOCALS:LCOUNT)
	;	CONTINUE
	CASE "Ｂ", "BOLD"
		FONTBOLD
		CONTINUE
	CASE "UNDER"
		FONTSTYLE 8
		CONTINUE
	CASE "ITALIC"
		FONTITALIC
		CONTINUE
	CASE "STRIKE"
		FONTSTYLE 4
		CONTINUE
	ENDSELECT

	PRINTFORM %LOCALS:LCOUNT%
	SETCOLOR nInitColor
	FONTREGULAR
NEXT

;-------------------------------------------------
;PRINT_STRの最後の_Lと_Wを関数に織り込んだver
;-------------------------------------------------
@PRINT_STRL, ARGS, ARGS:1, ARGS:2, ARGS:3, ARGS:4, ARGS:5, ARGS:6, ARGS:7, ARGS:8, ARGS:9
CALL PRINT_STR, ARGS, ARGS:1, ARGS:2, ARGS:3, ARGS:4, ARGS:5, ARGS:6, ARGS:7, ARGS:8, ARGS:9
PRINTL

@PRINT_STRW, ARGS, ARGS:1, ARGS:2, ARGS:3, ARGS:4, ARGS:5, ARGS:6, ARGS:7, ARGS:8, ARGS:9
CALL PRINT_STR, ARGS, ARGS:1, ARGS:2, ARGS:3, ARGS:4, ARGS:5, ARGS:6, ARGS:7, ARGS:8, ARGS:9
WAIT

@CLEARSTRTAGS(ARGS)
#FUNCTIONS
RETURNF REPLACE(ARGS, "HEX@.*?@|@L|@|BOLD", "")

; ;大きめのハートマーク
; @BIG_HEARTMARK
; SETFONT GET_EXFONT( 7, 8, 10 )	; "Miriam", "Verdana", "Times New Roman"
; PRINTFORM %UNICODE(0x2764)%
; SETFONT 

; ;白抜きのハート
; @WHITE_HEARTMARK
; SETFONT GET_EXFONT( 7, 8, 10 )	; "Miriam", "Verdana", "Times New Roman"
; PRINTFORM %UNICODE(0x2661)%
; SETFONT RESULTS

;-------------------------------------------------
;types characters gradually, original from tohoJ's Flandre dialogue
;also supports change from typed kana to kanji, which probably won't have any practical application in english
;TODO - currently doesn't work properly if the line wasn't empty to begin with
;@KEYTYPING
;変換前の文字列を1文字ずつ順に表示した後でそれを消して変換後の文字列を表示する。奇数は変換前、偶数は変換後。"/"で区切る。
;使用例：CALL KEYTYPING("あくま/悪魔", "W", 2)；あ → あく → あくま → 悪魔
;ARGS：元の文字列
;ARGS:1：入力待ちの有無
;additional flags - d: use dialogue quote marks, dc: use default color for text, l: break the line after output is over, w: break the line and wait
;multiple flags can be used with : as a separator
;ARG：表示速度 (delay after printing each character, smaller - faster) 
;Warning - with extra long delay (>1000) key detection becomes wonky so it's very hard to skip
;ARG:1 - how many characters print at once
;-------------------------------------------------
@KEYTYPING(ARGS, ARGS:1, ARG = 1, ARG:1 = 2)
#DIM LCOUNT, 2
#DIM nInitColor
#DIM nInitRedraw

nInitRedraw = CURRENTREDRAW()
;limit the arguments
SIF ARG <= 0
	ARG = 1
ARG:1 = LIMIT(ARG:1, 1, 9)

;process dialogue flag
SIF SPLIT_CHECK(TOLOWER(ARGS:1), "d")
	ARGS = 「%ARGS%」
;remember color when it's not default, reset the color if flag is set
nInitColor = GETCOLOR()
SIF SPLIT_CHECK(TOLOWER(ARGS:1), "dc")
	RESETCOLOR
	
VARSET LOCALS

REDRAW 0

;"/"で区切る
SPLIT ARGS, "/", LOCALS, LOCAL
IF MESSKIP() ;go here if skipping
	$SKIP
	FOR LCOUNT, 0, LOCAL, 2
		SIF LOCALS:(LCOUNT + 1) == ""
			LOCALS:(LCOUNT + 1) = %LOCALS:LCOUNT%
		IF !LCOUNT
			LOCALS = %LOCALS:(LCOUNT + 1)%
		ELSE
			LOCALS = %LOCALS%%LOCALS:(LCOUNT + 1)%
		ENDIF
	NEXT
ELSE
	;reset left mouse click detection
	GETKEYTRIGGERED 0x01
	;文字列を表示
	FOR LCOUNT, 0, LOCAL, 2
		FOR LCOUNT:1, 0, STRLENS(LOCALS:LCOUNT), ARG:1
			LOCAL:1 = LINECOUNT
			SIF LCOUNT
				PRINTFORM %LOCALS%
			PRINTFORML %SUBSTRING(LOCALS:LCOUNT, 0, LCOUNT:1)%
			IF MESSKIP() || GETKEYTRIGGERED(0x01) ;skip on left click or if text skipping was enabled prior
				CLEARLINE (LINECOUNT - LOCAL:1)
				GOTO SKIP
			ENDIF
			TWAIT ARG, 1
			CLEARLINE (LINECOUNT - LOCAL:1)
		NEXT
		SIF LOCALS:(LCOUNT + 1) == ""
			LOCALS:(LCOUNT + 1) = %LOCALS:LCOUNT%
		IF !LCOUNT
			LOCALS = %LOCALS:(LCOUNT + 1)%
		ELSE
			LOCALS = %LOCALS%%LOCALS:(LCOUNT + 1)%
		ENDIF
	NEXT
ENDIF

;入力待ち
PRINTS LOCALS
SIF SPLIT_CHECK(TOLOWER(ARGS:1), "l")
	PRINTL
SIF SPLIT_CHECK(TOLOWER(ARGS:1), "w")
	PRINTW 
	
SETCOLOR nInitColor
REDRAW nInitRedraw

@FIX_DIALOGUE_STATUS
FOR LOCAL, 0, CHARANUM
	;edit - reset faulty dialogue switchers only (coming from old saves most likely)

	;don't bother if the value is not tampered with
	SIF !CFLAG:LOCAL:구상셀렉터
		CONTINUE
	;check if the main dialogue still works with it
	TRYCCALLFORM M_KOJO_K{LOCAL}_{CFLAG:LOCAL:구상셀렉터}
		SIF !RESULT
			CFLAG:LOCAL:구상셀렉터 = 0
	CATCH
		CFLAG:LOCAL:구상셀렉터 = 0
	ENDCATCH
NEXT

;translate name/csv on character addition
;ARG to skip addchara and just init strings
@ADDCHARA_INIT(C_ID, ARG:0)
#DIM C_ID
SIF !ARG
	ADDCHARA C_ID ;add character
;replace untranslated values:
;set name
NAME:C_ID '= nameArray:C_ID:na_Name
;set callname
CALLNAME:C_ID '= nameArray:C_ID:na_Callname
SIF CSVCSTR(C_ID, 2) != "" ;workplace, printed at PRINT_STATE_PERSONAL
	CSTR:C_ID:직장 '= nameArray:C_ID:na_WorkPlace
SIF CSVCSTR(C_ID, 3) != "" ;work info, printed at WORK_INFO
	CSTR:C_ID:일정보 '= nameArray:C_ID:na_WorkInfo
;see explanation in _Name_Array.ERB
;SIF CSVCSTR(C_ID, 10) != "" ;title/ability/race, printed at PRINT_種族抽出 and PRINT_STATE_PERSONAL
;	CSTR:C_ID:10 '= nameArray:C_ID:na_Title

;get race/species part of the string from full title (cstr:10 originally)
@PRINT_GET_RACE(ARG)
#FUNCTIONS
#DIMS STR_LIST, 10
VARSET STR_LIST
;LOCALS = %nameArray:ARG:na_Title%
;IF STRFIND(LOCALS, "●") > -1
;	SPLIT LOCALS, "●", STR_LIST
;	FOR LOCAL, 0, RESULT
;		IF STRFIND(STR_LIST:LOCAL, "Race:") > -1
;			LOCALS:1 = %REPLACE(STR_LIST:LOCAL, "Race:", "")%
;			LOCALS:1 = %REPLACE(LOCALS:1, "　", "")%
;			LOCALS = %LOCALS:1%
;			BREAK
;		ENDIF
;	NEXT
;ELSEIF ARG == [[소악마]]
;	LOCALS = Demon
;;ELSEIF TALENT:ARG:스침
;;	PRINTFORM [인간]
;ELSEIF STRLENS(CSTR:ARG:모브코종족) ;for mobs
;	LOCALS '= RACE_TR(CSTR:ARG:모브코종족)
;ELSE
;	LOCALS =
;ENDIF
RETURNF LOCALS

;warning for the faulty cflag value
@EVENTLOAD
#LATER

LOCALS '= ""
LOCAL:1 = 0
FOR LOCAL, 1, CHARANUM
	;don't bother if the value is not tampered with
	SIF !CFLAG:LOCAL:구상셀렉터
		CONTINUE
	;check if the main dialogue still works with it
	TRYCCALLFORM M_KOJO_K{LOCAL}_{CFLAG:LOCAL:구상셀렉터}
		IF !RESULT
			LOCAL:1 ++
			LOCALS += CALLNAME:LOCAL + "、"
		ENDIF
	CATCH
		LOCAL:1 ++
		LOCALS += CALLNAME:LOCAL + "、"
	ENDCATCH
NEXT
IF LOCAL:1
	CALL COLORMESSAGE("Warning! Abnormal value for the dialogue selector detected!",C_RED,2,1)
	PRINTFORML Number of characters: {LOCAL:1}
	PRINTFORML Affected characters: %LIST_IN_STRING(LOCALS)%
	CALL COLORMESSAGE("Make sure to run [500] Update option from the main menu first!",C_RED,2,1)
ENDIF

;fix unset dick size tweak and etc
@EVENTLOAD
#LATER
FOR LOCAL, 0, CHARANUM
	SIF !HAS_PENIS(LOCAL)
		CONTINUE
	IF TALENT:LOCAL:형상 <= 0 || MAXBASE:LOCAL:정력 <= 0 || MAXBASE:LOCAL:발기 <= 0
		CALL COLORMESSAGE(@"Fixing incorrect penis properties for %CALLNAME:LOCAL%...",C_YELLOW,1,1)
		SIF TALENT:LOCAL:형상 <= 0 
			TALENT:LOCAL:형상 = 3
		SIF MAXBASE:LOCAL:발기 <= 0
			MAXBASE:LOCAL:발기 = 1500
		SIF MAXBASE:LOCAL:정력 <= 0
			MAXBASE:LOCAL:정력 = 1000
	ENDIF
	IF TALENT:LOCAL:절륜 && MAXBASE:LOCAL:발기 == 1500 ;addition custom code
		CALL COLORMESSAGE(@"Fixing incorrect max erection for %CALLNAME:LOCAL%...",C_YELLOW,1,1)
		MAXBASE:LOCAL:발기 *= 2
	ENDIF
	IF LOCAL == MASTER && MAXBASE:LOCAL:정력 == 1000 ;give back bonus vig the game owes you if you're at base VIG
		CALL Pc_Vig_Recover(MASTER) ;custom code
	ENDIF
NEXT

@Pc_Vig_Recover(ARG) ;add back bonus vig when it was reset, usually for PC
SIF GETBIT(FLAG:호감도보너스취득상황, 7)
	MAXBASE:ARG:정력 += 100
SIF GETBIT(FLAG:팬티보너스취득상황, 7)
	MAXBASE:ARG:정력 += 100
SIF GETBIT(FLAG:함락보너스취득상황, 6)
	MAXBASE:ARG:정력 += 100
SIF GETBIT(FLAG:함락보너스취득상황, 8)
	MAXBASE:ARG:정력 += 100
MAXBASE:ARG:정력 += nVigIncrease ;addition custom code
SIF TALENT:ARG:절륜
	MAXBASE:ARG:정력 += 300 ;addition custom code

;garbage collection from enter's emuera, wip possibly
;@EVENTLOAD
;#PRI
;CALL MEM_CLEAN

@EVENTEND
#LATER
CALL MEM_CLEAN

@MEM_CLEAN
;#; PRINTFORMW MemUse: {GETMEMORYUSAGE()/1024/1024}MB
LOCAL = CLEARMEMORY()
;#; PRINTFORMW Cleared: {LOCAL/1024/1024}MB MemUse: {GETMEMORYUSAGE()/1024/1024}MB

@CHARASORT_EX_TR
#FUNCTION
;the only issue here is that th98 characters start from range 201+, but it doesn't seem to be a big deal here?
;reminder to update this list whenever new characters are added!!!
VARSET RESULT, -1 ;set to -1 to include player character in the list
{
RESULT = MASTER,
[[레이무]], [[마리사]],
[[루미아]], [[대요정]], [[치르노]], [[메이링]], [[소악마]], [[파츄리]], [[사쿠야]], [[레밀리아]], [[플랑]],
[[레티]], [[첸]], [[앨리스]], [[릴리 W]], [[릴리 B]], [[리리카]], [[메를랑]], [[루나사]], [[요우무]], [[유유코]], [[란]], [[유카리]],
[[스이카]],
[[리글]], [[미스티아]], [[케이네]], [[테위]], [[우동게]], [[에이린]], [[카구야]], [[모코우]],
[[아야]], [[메디슨]], [[유카]], [[코마치]], [[에이키]],
[[시즈하]], [[미노리코]], [[히나]], [[니토리]], [[모미지]], [[사나에]], [[카나코]], [[스와코]],
[[서니]], [[루나]], [[스타]],
[[아큐]],
[[렌코]], [[메리]],
[[이쿠]], [[텐시]],
[[토요히메]], [[요리히메]], [[레이센]],
[[키스메]], [[야마메]], [[파르시]], [[유기]], [[사토리]], [[오린]], [[오쿠]], [[코이시]],
[[토키코]],
[[나즈린]], [[코가사]], [[이치린]], [[무라사]], [[쇼]], [[뱌쿠렌]], [[누에]],
[[하타테]],
[[카센]],
[[쿄코]], [[요시카]], [[청아]], [[토지코]], [[후토]], [[미코]], [[마미조]],
[[코스즈]], [[코코로]],
[[와카사기히메]], [[반키]], [[카게로]], [[벤벤]], [[야츠하시]], [[세이자]], [[신묘마루]], [[라이코]],
[[스미레코]], [[세이란]], [[링고]], [[도레미]], [[사구메]], [[클라운피스]], [[순호]], [[헤카티아]],
[[라바]], [[네무노]], [[아운]], [[나루미]], [[마이]], [[사토노]], [[오키나]],
[[조온]], [[시온]],
[[그림자카센]],
[[에이카]], [[우루미]], [[쿠타카]], [[야치에]], [[마유미]], [[케이키]], [[사키]], [[미요이]],
[[유마]],
[[미천]], 146, [[치야리]], [[히사미]], [[잔무]],
[[유겐마간]], [[엘리스]], [[사리엘]], [[미마]], [[키쿠리]], [[콘가라]],
[[리카]], [[메이라]],
[[엘렌]], [[코토히메]], [[카나]], [[리카코]], [[치유리]], [[유메미]], [[루코토]],
[[오렌지]], [[쿠루미]], [[엘리]], [[무게츠]], [[겐게츠]],
[[사라]], [[루이즈]], [[유키]], [[마이]], [[유메코]], [[신키]],
[[모브코]]
}

;create a list of options from branch mods as to not clog the option list
@OPTION_MOD
#DIM nLineCnt_Head 
FOR LOCAL, 0, 100
PRINTL
NEXT
CUSTOMDRAWLINE ＊
PRINTFORML Modded Options
CUSTOMDRAWLINE ＊
nLineCnt_Head = LINECOUNT
REDRAW 0
DO
	SIF LINECOUNT - nLineCnt_Head > 0
		CLEARLINE LINECOUNT - nLineCnt_Head
		
	FOR LOCAL, 0, 50
		TRYCALLFORM CUSTOM_OPTION_{LOCAL}
	NEXT
	
	CALL EQUATE_LINE, (nLineCnt_Head + 20) ;tweak when there's more options
	DRAWLINE
	PRINTFORML [999] - Return
	INPUT
	SELECTCASE RESULT
		CASE 999
			RETURN
	CASEELSE
		TRYCALLFORM CUSTOM_OPTION_RESULT_{RESULT}
	ENDSELECT
LOOP 1

;checks if all values exist within an array
@ARRAY_EXISTS_ALL(ARRAY, START, END, ARG:0, ARG:1, ARG:2 = -1, ARG:3 = -1, ARG:4 = -1, ARG:5 = -1, ARG:6 = -1, ARG:7 = -1, ARG:8 = -1, ARG:9 = -1)
#FUNCTION
#DIM REF ARRAY
#DIM START
#DIM END

FOR LOCAL, 0, 10
	SIF ARG:LOCAL < 0
		RETURNF 1
	SIF FINDELEMENT(ARRAY, ARG:LOCAL, START, END) < 0
		RETURNF 0
NEXT

RETURNF 1

;prints text in a box, similarly to omikuji and moriya blanks, to simulate a letter
;the box is always white, but the text uses the currently set color, allowing it to match a character's text color
;LINES=the text to be uses, with the lines separated by a /
;MINWIDTH=the minimum internal width of the box, in double-width characters
;MAXWIDTH=the maximum width of the box. any lines bigger than this will automatically be split up into separate lines with BREAKENG
;CENTERED=if 0, lines will be aligned left, if 1, lines will be centered
@PRINT_LETTER(LINES, MINWIDTH = 10, MAXWIDTH = -1, CENTERED = 0)
#DIMS LINES
#DIM  MINWIDTH
#DIM  MAXWIDTH
#DIM  CENTERED
#DIMS LINES_SPLIT, 20
#DIM  LINE_COUNT
#DIM DYNAMIC LINE_WIDTH

SIF !STRLENS(LINES)
    RETURN
SIF MAXWIDTH < 0
	MAXWIDTH = MAXWIDTH() / 2 - 2

SPLIT LINES, "/", LINES_SPLIT
LINE_COUNT = RESULT
FOR LOCAL, 0, LINE_COUNT
    LINE_WIDTH = MAX(LINE_WIDTH, STRLENS(LINES_SPLIT:LOCAL))
NEXT
;adjust to double-width characters
SIF LINE_WIDTH % 2 == 1
    LINE_WIDTH++
LINE_WIDTH /= 2
LINE_WIDTH = LIMIT(LINE_WIDTH, MINWIDTH, MAXWIDTH)

PRINTFORMDL ┌%"─"*LINE_WIDTH%┐

FOR LOCAL, 0, LINE_COUNT
    LOCALS '= BREAKENG(LINES_SPLIT:LOCAL,,,LINE_WIDTH*2)
	DEBUGPRINTFORML CONTENTS = "%LOCALS%"
    LOCAL:1 = 0
    WHILE STRFIND(LOCALS, "\n", LOCAL:1) >= 0
        LOCAL:2 = STRFIND(LOCALS, "\n", LOCAL:1)
        CALL PRINT_LETTER_LINE(SUBSTRING(LOCALS, LOCAL:1, LOCAL:2 - LOCAL:1), LINE_WIDTH, CENTERED)
        LOCAL:1 = LOCAL:2 + 1
    WEND
    CALL PRINT_LETTER_LINE(SUBSTRING(LOCALS, LOCAL:1), LINE_WIDTH, CENTERED)
NEXT

PRINTFORMDL └%"─"*LINE_WIDTH%┘

@PRINT_LETTER_LINE(LINE, LINE_WIDTH, CENTERED)
#DIMS LINE
#DIM  LINE_WIDTH
#DIM  CENTERED
#DIM  BLANK_SPACES
#DIM  TEXT_LENGTH

TEXT_LENGTH = STRLENS(LINE)
BLANK_SPACES = LINE_WIDTH - ((TEXT_LENGTH + (TEXT_LENGTH % 2)) / 2)
BLANK_SPACES = MAX(BLANK_SPACES, 0)

PRINTFORMD ｜
IF CENTERED
	PRINTFORM %"　"*(BLANK_SPACES / 2)%%COND_STR(" ", TEXT_LENGTH % 2 == 1)%%LINE%%"　"*(BLANK_SPACES - (BLANK_SPACES / 2))%
ELSE
	PRINTFORM %LINE%%COND_STR(" ", TEXT_LENGTH % 2 == 1)%%"　"*BLANK_SPACES%
ENDIF

PRINTFORMDL ｜
;==================================================================
;Return 1 if the target is under the effect of an aphrodisiac or in heat
;Borrowed from Kaguya's dialogue
;==================================================================
@IN_HEAT(ARG = -1)
#FUNCTION
SIF ARG == -1
	ARG = TARGET
RETURNF (TCVAR:TARGET:미약 || TCVAR:TARGET:발정)

;==================================================
;Determines if a character believes they still have all their applicable non-anal virginities
;==================================================
@THINKS_IS_VIRGIN(ARG = -1)
#FUNCTION
SIF ARG == -1
	ARG = TARGET
;SIF HAS_VAGINA(ARG) && !HAS_PENIS(ARG) && (VAGINAL_VIRGINITY_LOSS_WAS_UNAWARE(ARG) || TALENT:ARG:처녀 == 1)
SIF HAS_VAGINA(ARG) && !HAS_PENIS(ARG) && TALENT:ARG:처녀 == 1
	RETURNF 1
;SIF !HAS_VAGINA(ARG) && HAS_PENIS(ARG) && (PENILE_VIRGINITY_LOSS_WAS_UNAWARE(ARG) || IS_DOUTEI(ARG))
SIF !HAS_VAGINA(ARG) && HAS_PENIS(ARG) && IS_DOUTEI(ARG)
	RETURNF 1
;SIF HAS_VAGINA(ARG) && HAS_PENIS(ARG) && (PENILE_VIRGINITY_LOSS_WAS_UNAWARE(ARG) || IS_DOUTEI(ARG)) && (VAGINAL_VIRGINITY_LOSS_WAS_UNAWARE(ARG) || TALENT:ARG:처녀 == 1)
SIF HAS_VAGINA(ARG) && HAS_PENIS(ARG) && (IS_DOUTEI(ARG)) && (VAGINAL_VIRGINITY_LOSS_WAS_UNAWARE(ARG) || TALENT:ARG:처녀 == 1)
	RETURNF 1
RETURNF 0

@VAGINAL_VIRGINITY_LOSS_WAS_UNAWARE(ARG = -1)
#FUNCTION
SIF ARG == -1
	ARG = TARGET
RETURNF STRCOUNT( TOLOWER(CSTR:ARG:처녀상실이력), "stolen")

@PENILE_VIRGINITY_LOSS_WAS_UNAWARE(ARG = -1)
;#FUNCTION
;SIF ARG == -1
;	ARG = TARGET
;RETURNF STRCOUNT( TOLOWER(CSTR:ARG:童貞喪失履歴), "stolen")

;==================================================
;Determines if the player has all their applicable non-anal virginities (vaginal if female, penile if male, vaginal
;and penile if futa)
;==================================================
@MASTER_IS_VIRGIN()
#FUNCTION
RETURNF (IS_FEMALE(MASTER) && IS_VIRGIN(MASTER)) || (IS_MALE(MASTER) && IS_DOUTEI(MASTER)) || (IS_FUTA(MASTER) && IS_DOUTEI(MASTER) && IS_VIRGIN(MASTER))

;note - needs WAIT for W effect
;modified from COM616_EIRINSPEAK
@CUTSCENESPEAK(ARGS, ARGS:1 = "通常", ARG, ARG:1 = 1)
SIF ARGS:1 == "smile"
	ARGS:1 '= "笑顔"
SIF ARGS:1 == "blush"
	ARGS:1 '= "発情"
SIF ARGS:1 == "anger"
	ARGS:1 '= "怒り"
SIF ARGS:1 == "surprise"
	ARGS:1 '= "驚き"
DEBUGPRINTFORML Calling SPTALK with args {ARG}, %ARGS:1%, 1, %ARGS%, 1
CALL SPTALK, ARG, ARGS:1, 1, ARGS, 1
SIF ARG:1 == 1
	WAIT

;==================================================
;Returns 3 if the character is a doll
;Returns 2 if the character is a non-youkai nonhuman
;Returns 1 if the character is a youkai
;Returns 0 if the character is a human
;==================================================
@IS_NONHUMAN(ARG = -1)
#FUNCTION
SIF ARG == -1
	ARG = MASTER

;Human and not Were-Hakutaku
IF TALENT:ARG:인간 && !TALENT:ARG:반백택
	SELECTCASE TALENT:ARG:인간
		;Human = Human
		CASE 1
			RETURNF 0
		;Celestial, Lunarian = non-youkai non-human
		CASE 3, 4
			RETURNF 2
		CASE 5 ;Makai Resident = youkai
			RETURNF 1
		;Hermits and Outsiders can be humans, youkai, or neither so we keep checking
	ENDSELECT
ENDIF

;hack to ensure Narumi is treated as a youkai
;Jizo and Magician = youkai
IF TALENT:ARG:인형 == 3 && TALENT:ARG:추가종족 == 2
	RETURNF 1
;Doll
ELSEIF TALENT:ARG:인형
	RETURNF 3
;Jiang-Shi or Yuki-Onna = Youkai
ELSEIF TALENT:ARG:인형 == 5 || TALENT:ARG:빙정 == 2
	RETURNF 1
;Ice Fairy, Fairy, Divine Spirit, Phantom, Doll = non-youkai non-human
ELSEIF TALENT:ARG:빙정 || TALENT:ARG:요정 || TALENT:ARG:신령 || TALENT:ARG:유령
	RETURNF 2
;Kitsune, Youkai, Youkai, Tsukumogami, Were-Hakutaku, Magician, Animal Ears = youkai
ELSEIF TALENT:ARG:여우 || TALENT:ARG:요호 || TALENT:ARG:요괴 || TALENT:ARG:츠쿠모가미 || TALENT:ARG:반백택 || TALENT:ARG:추가종족 == 2 || TALENT:ARG:동물귀
	RETURNF 1
ENDIF
;Anything else is human
RETURNF 0

;==================================================
;Returns "-chan" or "-kun" depending on the gender of the character you pass to it
;==================================================
@CHAN_KUN(ARG)
#FUNCTIONS
IF IS_MALE(ARG)
	RETURNF @"%CALLNAME:ARG%-kun"
ELSE
	RETURNF @"%CALLNAME:ARG%-chan"
ENDIF

;==================================================
;Copied from MORELOVER.ERB
;Counts the number of lovers the player has
;==================================================
@LOVER_COUNT()
#FUNCTION
#DIM DYNAMIC LOVERCOUNT
FOR LOCAL,1,CHARANUM
	IF TALENT:LOCAL:연인
		LOVERCOUNT ++
	ENDIF
NEXT
RETURNF LOVERCOUNT

;==================================================
;A helper function for returning the value of a variable
;Mostly used for checking the status of MORELOVER without running into "undefined variable" errors on the translation branch
;Returns the value of the variable if it exists, or 0 if it doesn't
;==================================================
@RETURN_VAR_VALUE_IF_EXISTS(ARGS)
#FUNCTION
SIF EXISTVAR(ARGS)
	RETURNF GETVAR(ARGS)
RETURNF 0

;==========================================================================
;Returns 1 if the character has any of Yearning, Love, Fuck Buddy, or Lust
;==========================================================================
@IS_FALLEN(ARG = -1)
#FUNCTION
SIF ARG == -1
	ARG = TARGET
RETURNF TALENT:ARG:사모 || TALENT:ARG:연모 || TALENT:ARG:섹프 || TALENT:ARG:애욕

;==========================================================================
;Returns 1 if the character has a hate mark or is angry
;==========================================================================
@IS_ANGERY(ARG = -1)
#FUNCTION
SIF ARG == -1
	ARG = TARGET
RETURNF MARK:ARG:반발각인 || CFLAG:ARG:빡침

;==================================================
;number of people in location
;does not include player
;From /egg/ Sakuya's dialogue
;==================================================
@NUMBER_OF_PEOPLE(ARG)
#FUNCTION
#DIM iNumOfPeople

iNumOfPeople = 0
FOR LOCAL,1,CHARANUM
	SIF CFLAG:LOCAL:동실
		iNumOfPeople ++
NEXT
RETURNF iNumOfPeople

;==========================================================================
;Returns 1 if the character can impregnate others and/or get pregnant
;==========================================================================
@CAN_REPRODUCE(ARG)
#FUNCTION
IF !IS_CHILD(ARG)
	RETURNF 1
ELSE
	IF HAS_VAGINA(ARG) && TALENT:ARG:초경 ;First Menstruation
		RETURNF 1
	ELSEIF HAS_PENIS(ARG) && IS_SPERMARCHE(ARG)
		RETURNF 1
	ELSE
		RETURNF 0
	ENDIF
ENDIF

;==========================================================================
;Checks if character is erect
;Returns 0 if character has no penis or is completely flaccid
;Returns 1 if character has no penis or is soft
;Returns 2 if character has penis and is at least Hard
;Returns 3 if character has penis and is ERECT!!
;==========================================================================
@IS_ERECT(ARG)
#FUNCTION
SIF !HAS_PENIS(ARG) ;Doesn't have a penis
	RETURNF 0
IF BASE:ARG:발기 >= 1500 ;Current erection value is equal to default max erection value
	RETURNF 3
ELSEIF BASE:ARG:발기 >= 1000 ;Erection value is equal or bigger than 1000 (Hard)
	RETURNF 2
ELSEIF BASE:ARG:발기 >= 500 ;(Soft)
	RETURNF 1
ELSE ;(Flaccid)
	RETURNF 0
ENDIF

;returns true if all passed characters are in the same location as MASTER
@IS_HERE(ARG, ARG:1=-1, ARG:2=-1, ARG:3=-1, ARG:4=-1, ARG:5=-1, ARG:6=-1, ARG:7=-1, ARG:8=-1, ARG:9=-1)
#FUNCTION
LOCAL:1 = FINDELEMENT(ARG, -1)
SIF LOCAL:1 == -1
    LOCAL:1 = 10
FOR LOCAL, 0, LOCAL:1
    SIF CFLAG:MASTER:현재위치 != CFLAG:(ARG:LOCAL):현재위치
        RETURNF 0
NEXT
RETURNF 1

;returns true if all passed characters have been met
@IS_MET(ARG, ARG:1=-1, ARG:2=-1, ARG:3=-1, ARG:4=-1, ARG:5=-1, ARG:6=-1, ARG:7=-1, ARG:8=-1, ARG:9=-1)
#FUNCTION
LOCAL:1 = FINDELEMENT(ARG, -1)
SIF LOCAL:1 == -1
    LOCAL:1 = 10
FOR LOCAL, 0, LOCAL:1
    SIF !CFLAG:(ARG:LOCAL):안면
        RETURNF 0
NEXT
RETURNF 1

;returns true if all passed characters are not disabled
@IS_ENABLED(ARG, ARG:1=-1, ARG:2=-1, ARG:3=-1, ARG:4=-1, ARG:5=-1, ARG:6=-1, ARG:7=-1, ARG:8=-1, ARG:9=-1)
#FUNCTION
LOCAL:1 = FINDELEMENT(ARG, -1)
SIF LOCAL:1 == -1
    LOCAL:1 = 10
FOR LOCAL, 0, LOCAL:1
    SIF CFLAG:(ARG:LOCAL):출금
        RETURNF 0
NEXT
RETURNF 1

;returns true if all passed characters have been met and are not disabled
@IS_MET_ENABLED(ARG, ARG:1=-1, ARG:2=-1, ARG:3=-1, ARG:4=-1, ARG:5=-1, ARG:6=-1, ARG:7=-1, ARG:8=-1, ARG:9=-1)
#FUNCTION
LOCAL:1 = FINDELEMENT(ARG, -1)
SIF LOCAL:1 == -1
    LOCAL:1 = 10
FOR LOCAL, 0, LOCAL:1
    SIF !CFLAG:(ARG:LOCAL):안면 || CFLAG:(ARG:LOCAL):출금
        RETURNF 0
NEXT
RETURNF 1

;returns true if MASTER is any of the passed characters
@IS_MASTER(ARG, ARG:1=-1, ARG:2=-1, ARG:3=-1, ARG:4=-1, ARG:5=-1, ARG:6=-1, ARG:7=-1, ARG:8=-1, ARG:9=-1)
#FUNCTION
LOCAL:1 = FINDELEMENT(ARG, -1)
SIF LOCAL:1 == -1
    LOCAL:1 = 10
FOR LOCAL, 0, LOCAL:1
    SIF FLAG:역극 == ARG:LOCAL || ARG:LOCAL == 0
        RETURNF 1
NEXT
RETURNF 0

;returns true if the weather is bad for being outside
@IS_BAD_WEATHER
#FUNCTION
SIF GROUPMATCH(TIME:5,4,5,6,9,12,13,14,15) || GROUPMATCH(FLAG:이상기상,9,10)
	RETURNF 1
RETURNF 0

;returns true if there's a storm happening
@IS_STORM
#FUNCTION
SIF GROUPMATCH(TIME:5,9,13,14,15) || GROUPMATCH(FLAG:이상기상,9,10)
	RETURNF 1
RETURNF 0

;prints a line of text in a character's color
@CHARA_TEXT(ARG, ARGS, MODE = "l")
#DIMS MODE
LOCAL = GETCOLOR()
RESETCOLOR
SIF FLAG:구상색
    CALL SET_KOJO_COLOR(ARG)
SELECTCASE MODE
    CASE "l", "L"
        PRINTFORML %ARGS%
    CASE "w", "W"
        PRINTFORMW %ARGS%
	CASE "str", "STR"
		CALL PRINT_STR, ARGS
	CASE "strl", "STRL"
		CALL PRINT_STRL, ARGS
	CASE "strw", "STRW"
		CALL PRINT_STRW, ARGS
    CASEELSE
        PRINTFORM %ARGS%
ENDSELECT
SETCOLOR LOCAL

;some font names need double checking
@CHKFONTNAME(ARGS)
#FUNCTIONS
#DIMS strProbFontName = "ＭＳ Ｐゴシック", "ＭＳ ゴシック", "メイリオ", "ＭＳ Ｐ明朝"
#DIMS strFixedFontName = "MS PGothic", "MS Gothic", "Meiryo", "MS PMincho"
FOR LOCAL, 0, VARSIZE("strProbFontName")
	IF ARGS == strProbFontName:LOCAL && !CHKFONT(ARGS)
		SIF CHKFONT(strFixedFontName:LOCAL);return fixed name if it works, otherwise just give up and return the original
			RETURNF strFixedFontName:LOCAL
	ENDIF
NEXT

RETURNF ARGS

;Determines if a character can visit your home map
;Made this a function to avoid code reduplication
@CAN_VISIT(ARG)
#FUNCTION
IF FLAG:교류내방모드 == 1 && CFLAG:ARG:호감도 <= 50
	RETURNF 0
ELSEIF FLAG:교류내방모드 == 2 && !TALENT:ARG:사모 && !IS_LOVER(ARG) && !TALENT:ARG:연인 && !TALENT:ARG:섹프
	RETURNF 0
ELSEIF FLAG:교류내방모드 == 3
	RETURNF 0
ELSE
	RETURNF 1
ENDIF

;returns the name for the dish with the specified id without affecting the existing values for held food
@FOOD_NAME(DISH_NUM)
#DIM DISH_NUM
#DIMS TEMP_DISH_NAME
#DIMS TEMP_DISH_TASTE
#DIMS TEMP_DISH_COMMENT
#DIM TEMP_DISH_ING,11
#DIM TEMP_DISH_TIME
#DIM TEMP_DISH_MAXLIMIT

;temporarily store currently held data so we can use DISHDATA to retrieve the name
TEMP_DISH_NAME '= DISH_NAME
TEMP_DISH_TASTE '= DISH_TASTE
TEMP_DISH_COMMENT '= DISH_COMMENT
ARRAYCOPY "DISH_ING", "TEMP_DISH_ING"
TEMP_DISH_TIME = DISH_TIME
TEMP_DISH_MAXLIMIT = DISH_MAXLIMIT

CALL DISHDATA(DISH_NUM)
RESULTS '= DISH_NAME

;reset values to previous
DISH_NAME '= TEMP_DISH_NAME
DISH_TASTE '= TEMP_DISH_TASTE
DISH_COMMENT '= TEMP_DISH_COMMENT
ARRAYCOPY "TEMP_DISH_ING", "DISH_ING"
DISH_TIME = TEMP_DISH_TIME
DISH_MAXLIMIT = TEMP_DISH_MAXLIMIT

;generic version of K30_FIND_LOVER
;Return values:
;-1: Lover is ARG
; 0: MASTER has no lover
; 1: Lover is not here
; 2: Lover is present
@FIND_LOVER(ARG = - 1)
#FUNCTION
SIF ARG == -1
	ARG = TARGET
SIF TALENT:MASTER:연인 == 0
	RETURNF 0
SIF TALENT:ARG:연인
	RETURNF -1
SIF GET_TARGETNUM() < 2
	RETURNF 1
FOR LOCAL, 1, GET_TARGETNUM() + 1
	SIF TALENT:(TARGET:LOCAL):연인
		RETURNF 2
NEXT
RETURNF 1

;generic version of K30_FIND_AROUND
;Returns a random person at this location, prioritizing lovers and acquintances if desired 
;ACQUAINTANCES: passes a list of priority characters
;OPTION: 0 to prioritize lovers then acquaintances then everyone else, 1 to not prioritize anyone
;		, 2 to prioritize lovers, but not acquaintances, 3 to prioritize acquaintances but not lovers
;RANDOM_ACQUAINTANCE: if 0, acquaintances are prioritized as they are listed, if 1, a random acquaintance is picked
@FIND_AROUND(ACQUAINTANCES, MODE = 0, RANDOM_ACQUAINTANCE = 0)
#FUNCTION
#DIM TARGETNUM
#DIM DYNAMIC VALID_CHARA_COUNT
#DIM REF ACQUAINTANCES
#DIM MODE
#DIM DYNAMIC SEARCH_MODE ;0=randoms, 1=acquiantances, 2=lovers
#DIM CHARA
#DIM RANDOM_ACQUAINTANCE
#LOCALSIZE キャラクタ数上限
VARSET LOCAL
TARGETNUM = GET_TARGETNUM() 
;部屋に映姫様一人なら当然0
SIF TARGETNUM == 1
	RETURNF 0

FOR COUNT,1, TARGETNUM + 1
	CHARA = TARGET:COUNT
	;地獄の断頭台withジェロニモ状態を防ぐため口上主はスキップ
	SIF CHARA == TARGET
		CONTINUE

	IF GROUPMATCH(MODE, 0, 2) ;lovers first
		IF TALENT:CHARA:연인
			IF SEARCH_MODE < 2 ;discard the old list, increase priority
				VARSET LOCAL
				VALID_CHARA_COUNT = 0
				SEARCH_MODE = 2
			ENDIF
			LOCAL:(VALID_CHARA_COUNT++) = CHARA
			CONTINUE
		ELSEIF SEARCH_MODE == 2 ;only lovers allowed at this point, discard
			CONTINUE
		ENDIF
	ENDIF

	IF GROUPMATCH(MODE, 0, 3) ;acquaintances second
		IF FINDELEMENT(ACQUAINTANCES, CHARA) >= 0
			IF SEARCH_MODE < 1 ;discard the old list, increase priority
				VARSET LOCAL
				VALID_CHARA_COUNT = 0
				SEARCH_MODE = 1
			ENDIF
			LOCAL:(VALID_CHARA_COUNT++) = CHARA
			CONTINUE
		ELSEIF SEARCH_MODE == 1 ;only acquiantances allowed at this point, discard
			CONTINUE
		ENDIF
	ENDIF

	;配列のカウントは別で取りながら代入
	LOCAL:(VALID_CHARA_COUNT++) = CHARA
NEXT

;この条件でここまで来たのはなんでだろう
;ともかくエラー出さないためにヨシ！
SIF VALID_CHARA_COUNT < 1
	RETURNF 0

SIF SEARCH_MODE == 1 && !RANDOM_ACQUAINTANCE ;pick first in list
	RETURNF LOCAL:0

;prioritize date partner amongst lovers, if possible
SIF SEARCH_MODE == 2 && FLAG:데이트상대 && TALENT:(FLAG:데이트상대):연인
	RETURNF FLAG:데이트상대

;抽選してIDを決定
RETURNF LOCAL:(RAND(VALID_CHARA_COUNT))

@PRINT_BREAK_HTML(MAX_LINE_WIDTH)
#DIM  MAX_LINE_WIDTH
#DIMS HTML_SOURCE_TEXT
#DIMS DYNAMIC HTML_RESULT_TEXT
#DIM  DYNAMIC CURRENT_POS
#DIM  DYNAMIC LINE_POS
#DIM  TEXT_LENGTH
#DIMS HTML_SEGMENT
#DIMS ACTUAL_SEGMENT
#DIM  HTML_SEGMENT_LENGTH
#DIM  ACTUAL_SEGMENT_LENGTH
#DIM  SPACE_POS
SIF !MAX_LINE_WIDTH
	MAX_LINE_WIDTH = MAXWIDTH()-19

HTML_SOURCE_TEXT '= HTML_POPPRINTINGSTR()
; DEBUGPRINTFORML Raw HTML line:
; DEBUGPRINTFORML %HTML_SOURCE_TEXT%

HTML_SOURCE_TEXT '= REPLACE(HTML_SOURCE_TEXT, "<br>", "") ;remove existing line breaks
;STRFIND does not use REGEX, so we instead replace all target spaces with ␝ and work with that
;this could probably be optimized with good use of REGEXPMATCH
HTML_SOURCE_TEXT '= REPLACE(HTML_SOURCE_TEXT, " +(?![^<]*\>)", "␝")
TEXT_LENGTH = STRLENS(HTML_SOURCE_TEXT)

WHILE CURRENT_POS < TEXT_LENGTH
	SPACE_POS = STRFIND(HTML_SOURCE_TEXT, "␝", CURRENT_POS)
	IF SPACE_POS < 0
		SPACE_POS = TEXT_LENGTH
	ENDIF
	HTML_SEGMENT_LENGTH = SPACE_POS + 1 - CURRENT_POS
	HTML_SEGMENT '= SUBSTRING(HTML_SOURCE_TEXT, CURRENT_POS, HTML_SEGMENT_LENGTH)
	ACTUAL_SEGMENT_LENGTH = STRLENS(HTML_TOPLAINTEXT(HTML_SEGMENT))

	;if we ever get a segment that's too big to fit on one line, just throw it in there and start a new line
	IF ACTUAL_SEGMENT_LENGTH > MAX_LINE_WIDTH
		HTML_RESULT_TEXT += REPLACE(HTML_SEGMENT, "␝", "")
		HTML_RESULT_TEXT += "<br>"
		LINE_POS = 0
		CURRENT_POS += HTML_SEGMENT_LENGTH
		CONTINUE
	ELSEIF LINE_POS + ACTUAL_SEGMENT_LENGTH > MAX_LINE_WIDTH
		;new line
		HTML_RESULT_TEXT += "<br>"
		LINE_POS = 0
	ENDIF
	HTML_RESULT_TEXT += HTML_SEGMENT
	LINE_POS += ACTUAL_SEGMENT_LENGTH
	CURRENT_POS += HTML_SEGMENT_LENGTH
WEND
;restore spaces
HTML_RESULT_TEXT '= REPLACE(HTML_RESULT_TEXT, "␝", " ")
HTML_PRINT HTML_RESULT_TEXT

@D_LINE
LOCAL = GETCOLOR()
RESETCOLOR
DRAWLINE
SETCOLOR LOCAL

;push player down, originally K41_PUSHDOWN
@INSTANT_PUSHDOWN
;挿入中は駄目
TEQUIP:50 = -1
TEQUIP:51 = -1
;シャワー中はダメ
TEQUIP:32 = 0
;乳首吸い中はダメ
TEQUIP:41 = 0
;乳揉み中はダメ
TEQUIP:42 = 0
;계속키스
TEQUIP:계속키스 = 0
CFLAG:MASTER:우후후 = 2
TFLAG:COMABLE관리 = 3
FOR LOCAL,1,GET_TARGETNUM() + 1
	SIF TARGET:LOCAL <= 0
		CONTINUE
	SIF !SHIRAHU(TARGET:LOCAL)
		CONTINUE
	SIF GETBIT(FLAG:잠복, 0) && !GETBIT(CFLAG:(TARGET:LOCAL):잠복상태, 0) ;concealment, only apply to the target
		CONTINUE
	CFLAG:(TARGET:LOCAL):우후후 = 2
NEXT
TIME += 5

;taken from K30_QUAKE
@QUAKE(ARG = 2)
#LOCALSIZE 3
;表示オフだと戻る
;SIF !ANIME_CONFIG("QUAKE")
;	RETURN RESULT
REDRAW 0
FOR LOCAL, 0, ARG
	LOCAL:1 = RAND:4+1
	FOR LOCAL:2, 0, LOCAL:1
		PRINTL 
	NEXT
	TWAIT 100, 0
	CLEARLINE LOCAL:1
	TWAIT 100, 0
NEXT
REDRAW 3
RETURN RESULT

;Originally K97_RUNOFF
@RUNOFF(ARG, PASS_TIME = 1)
#DIM PASS_TIME
CFLAG:ARG:데일리 = 0
CFLAG:ARG:행동 = 0
BASE:ARG:일량 = 0
CFLAG:ARG:현재위치 = SUKIMA()
CFLAG:ARG:거점내방 = 0
CFLAG:ARG:동실 = 0
IF FLAG:데이트상대 == ARG
	CFLAG:ARG:데이트중 = -1
	FLAG:데이트상대 = 0
ENDIF
SIF PASS_TIME
	TIME += 5
CALL TARGETSET_CHACK

; Like GIFT_DATE_EVENT, but without the date-specific text
@GIFT_EVENT(CHARA)
#DIM CHARA
#DIM GIFT_ID
#DIMS GIFT_NAME
#DIM 渡した回数
#DIM 点数
#DIM 本人の評価点
#DIMS GIFT_SENSE


;点数は必要ないけど一応
点数 = 0

;贈り物生成
CALL CREATE_GIFT_FROM_CHARA(CHARA, 701, 1000)
GIFT_ID = RESULT
GIFT_NAME = %RESULTS%
GIFT_SENSE = %RESULTS:1%
渡した回数 = GET_GIFTDATA(CFLAG:CHARA:건네준선물, "回数") + 1
本人の評価点 = RESULT:1
;IDの設定
GIFT_ID = 渡した回数 * 10000000000000000 + 点数 * 10000000000000 + DAY * 1000000000 + CFLAG:MASTER:데이트중 * 10000000 + GIFT_ID
GIFT_GAVE:CHARA:(渡した回数 % 100) = GIFT_ID
CFLAG:CHARA:건네준선물 = GIFT_ID
CALL KOJO_MESSAGE_SEND("GIFT", 6, CHARA, GIFT_ID, 本人の評価点, GIFT_NAME, GIFT_SENSE)
PRINTFORMW Received [%GIFT_NAME%] from %CALLNAME:CHARA%!

;Copy-pasted from ALCOHOL_FACE_TR
;Returns 0 if the character is sober, 1 if the character is Tipsy, 2 if the character is Drunk, and 3 if the character is Wasted
@IS_DRUNK(CHARA)
#FUNCTION
#DIM CHARA
SIF BASE:CHARA:술기운 <= 2
	RETURNF 0
SELECTCASE BASE:CHARA:술기운
	CASE IS > (MAXBASE:CHARA:술기운 / 10) * 8
		RETURNF 3
	CASE IS > (MAXBASE:CHARA:술기운 / 10) * 5
		RETURNF 2
	CASE IS <= (MAXBASE:CHARA:술기운 / 10) * 5
		RETURNF 1
ENDSELECT

	
;-------------------------------------------------
;create written set of flags without magic numbers and FIRSTTIME abuse
;original from SQ's CEVENT
;@CEVENTはキャラクターごとの各種イベントの記録を参照する関数。経験済みなら１を、未経験なら０を返す
;セットする時には@SET_CEVENTを用い、消去する際には@DEL_CEVENTを使う
;記録にはcEventを使い、cEvent = イベント１/イベント２/ と"/"を用いて区切る
;特殊なイベント群を作る際には、頭に"イベント名："とするのを推奨
;また、記述と操作の都合により、全角の"："と"＾"、半角の"/"の使用は禁止
;-------------------------------------------------
@CEVENT(ARGS, ARG)
#FUNCTION
SIF ARG == 0 && TARGET
	ARG = TARGET

;ARGS = %ARGS%/

;既にイベント経験済みかを調べる
RETURNF SPLIT_CHECK_C(cEvent:ARG:0, "/", ARGS)

@SET_CEVENT(ARGS, ARG)
#FUNCTION
SIF ARG == 0 && TARGET
	ARG = TARGET

;ARGS = %ARGS%/

;経験済みなら追加せずに終了
SIF SPLIT_CHECK_C(cEvent:ARG:0, "/", ARGS)
	RETURNF 1

;経験していないなら追加
cEvent:ARG:0 = %cEvent:ARG:0%%ARGS%/

@DEL_CEVENT(ARGS, ARG)
#FUNCTION
#DIMS DYNAMIC strTemp, 999 ;increase limit if needed
#DIM nLoop
SIF ARG == 0 && TARGET
	ARG = TARGET

;イベントごとに分解する
SPLIT cEvent:ARG:0, "/", strTemp

;一旦cEventを初期化
cEvent:ARG:0 = 

FOR nLoop, 0, VARSIZE("strTemp")
	SIF strTemp:nLoop == ""
		BREAK
	;経験済みだった
	SIF ARGS == strTemp:nLoop
		CONTINUE

	;経験していないなら戻す
	cEvent:ARG:0 = %cEvent:ARG:0%%strTemp:nLoop%/
NEXT

@CLEAR_CEVENT(ARG)
#FUNCTION
cEvent:ARG:0 '= ""

;translate name/csv on character addition
;ARG to skip addchara and just init strings
@ADDCHARA_INIT(C_ID, ARG:0)
#DIM C_ID
SIF !ARG
	ADDCHARA C_ID ;add character
;replace untranslated values:
;set name
NAME:C_ID '= nameArray:C_ID:na_Name
;set callname
CALLNAME:C_ID '= nameArray:C_ID:na_Callname
SIF CSVCSTR(C_ID, 2) != "" ;workplace, printed at PRINT_STATE_PERSONAL
	CSTR:C_ID:직장 '= nameArray:C_ID:na_WorkPlace
SIF CSVCSTR(C_ID, 3) != "" ;work info, printed at WORK_INFO
	CSTR:C_ID:일정보 '= nameArray:C_ID:na_WorkInfo
;see explanation in _Name_Array.ERB
;SIF CSVCSTR(C_ID, 10) != "" ;title/ability/race, printed at PRINT_種族抽出 and PRINT_STATE_PERSONAL
;	CSTR:C_ID:10 '= nameArray:C_ID:na_Title

;get race/species part of the string from full title (cstr:10 originally)
@PRINT_GET_RACE(ARG)
#FUNCTIONS
#DIMS STR_LIST, 10
VARSET STR_LIST

;LOCALS = %nameArray:ARG:na_Title%
;IF STRFIND(LOCALS, "●") > -1
;	SPLIT LOCALS, "●", STR_LIST
;	FOR LOCAL, 0, RESULT
;		IF STRFIND(STR_LIST:LOCAL, "Race:") > -1
;			LOCALS:1 = %REPLACE(STR_LIST:LOCAL, "Race:", "")%
;			LOCALS:1 = %REPLACE(LOCALS:1, "　", "")%
;			LOCALS = %LOCALS:1%
;			BREAK
;		ENDIF
;	NEXT
;ELSEIF ARG == [[소악마]]
;	LOCALS = Demon
;;ELSEIF TALENT:ARG:스침
;;	PRINTFORM [인간]
;ELSEIF STRLENS(CSTR:ARG:모브코종족) ;for mobs
;	LOCALS '= RACE_TR(CSTR:ARG:모브코종족)
;ELSE
;	LOCALS =
;ENDIF
RETURNF LOCALS

;create buttons
;extra flags: onetime - show if the option can only be used once, even just viewing it, needs a flag in the following argument,
;if using FIRSTTIME - make sure the non-activation flag is set for it or it'll trigger right there
;-
;status - show status of the setting (bool only), specify status in a split afterwards (eg: "status:Disabled:Enabled"); needs a flag in the following argument
;cond - only accessible if the condition is true, needs a flag in the following argument
@KOJO_OPTION_ITEM(ARGS, ARG = 1, strExtra, nFlag)
#DIMS strExtra
#DIM nFlag

PRINTBUTTON @"[{ARG,2}] %ARGS%", ARG + 7000
SIF SPLIT_CHECK(strExtra, "status")
	PRINTFORM : \@ !nFlag ? %SPLIT_SINGLE(strExtra, 1)% # %SPLIT_SINGLE(strExtra, 2)% \@
IF SPLIT_CHECK(strExtra, "onetime")
	SETBIT KojoUpdateFlags:ARG, 0 ;set up a flag to let the input know
	PRINTFORML
	IF nFlag
		CALL COLORMESSAGE("One-time option used. Character reset or NG+ is required to change it again.",C_YELLOW,0)
		SETBIT KojoUpdateFlags:ARG, 1 ;option used
	ELSE
		CALL COLORMESSAGE("One-time option!",C_RED,0,1)
	ENDIF
ENDIF
IF SPLIT_CHECK(strExtra, "cond") && !nFlag
	SETBIT KojoUpdateFlags:ARG, 2 ;disable option
	CALL COLORMESSAGE("　(Non-applicable)",C_GRAY)
ENDIF
PRINTFORML

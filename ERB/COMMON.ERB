;함수 두는 곳
;-------------------------------------------------
;아이템 판매 상황 @ITEMSTOCK
;반환값 1 아이템이 존재하지 않음
;반환값 2 품절
;반환값 3 돈이 부족함
;반환값 4 조건을 충족하지 않았음
;반환값 5 이미 99개 소지하고 있음
;-------------------------------------------------
@ITEMSTOCK(ARG, 値段)
#FUNCTION
#DIM 値段
SIF !STRLENS(ITEMNAME:ARG)
	RETURNF 1
SIF ITEMSALES:ARG == -2
	RETURNF 4
SIF ITEMSALES:ARG == -1
	RETURNF 2
SIF MONEY < 물가적용(値段)
	RETURNF 3
;소지수제한 제압
;SIF ITEM:ARG >= 99
;	RETURNF 5
RETURNF 0

;-------------------------------------------------
;함수명 :CHOICE
;개요:2~4택함수
;인수 :ARGS:0…질문 내용
;      :ARGS:1~4…선택지의 캐릭터라인(3,4는 생략가능)
;반환값:유저 입력 결과(0~3)
;선택 조건이 없는, 심플한 선택지 작성 함수
;말등으로도 사용할 수 있을지도 모른다
;우선 4택까지. 늘려도 괜찮은데
;-------------------------------------------------
@CHOICE(ARGS:0, ARGS:1, ARGS:2, ARGS:3, ARGS:4)
PRINTSL ARGS:0
FOR LOCAL, 0, 4
	PRINTFORML [{LOCAL}] - %ARGS:(1 + LOCAL)%
	SIF LOCAL && !STRLENS(ARGS:(2 + LOCAL))
		BREAK
NEXT
$INPUT_LOOP
INPUT
SELECTCASE RESULT
	CASE 0 TO LOCAL - 1
	CASEELSE
		CALL SIMATTYAUOJISAN
		CLEARLINE 1
		GOTO INPUT_LOOP
ENDSELECT
RETURN RESULT
;-------------------------------------------------
;선택지를 표시해 입력 결과를 돌려주는 함수 조건을 채우지 않는 선택지를 회색 표시로 해 무효로 하는 것이 가능
;인수에 대사와 조건(0으로 무효, 비0으로 유효)을 지정. 최대 7개까지
;반환값은 선택한 선택지의 번호
;-------------------------------------------------
@ASK_M(ARGS:0, ARG:0, ARGS:1, ARG:1, ARGS:2, ARG:2, ARGS:3, ARG:3, ARGS:4, ARG:4, ARGS:5, ARG:5, ARGS:6, ARG:6, ARGS:7, ARG:7, ARGS:8, ARG:8)
#DIM CONST 선택지상한 = 8
CURRENTREDRAW
LOCAL:0 = RESULT
REDRAW 0
FOR LOCAL:0, 0, (선택지상한 + 1)
	IF ARGS:(LOCAL:0) != ""
		IF ARG:(LOCAL:0)
			PRINTBUTTON @"{LOCAL:0, 2, RIGHT}[%ARGS:(LOCAL:0)%]", LOCAL:0
		ELSE
			SETCOLOR 0x606060
			PRINTPLAINFORM {LOCAL:0, 2, RIGHT}[%ARGS:(LOCAL:0)%]
			RESETCOLOR
		ENDIF
		PRINTL 
	ENDIF
NEXT
$INPUT_LOOP
INPUT
IF RESULT < 0 || RESULT > 선택지상한 || ARGS:RESULT == "" || !ARG:RESULT
	CLEARLINE 1
	GOTO INPUT_LOOP
ENDIF
REDRAW LOCAL:0
RETURN RESULT
;-------------------------------------------------
;현금과 카리스마 어디라도 지불할 수 있는 선택지를 위한 함수
;-------------------------------------------------
@PAY_YEN_OR_CM(ARG, ARG:1)
PRINTFORML [0] 그만둔다
PRINTFORML [1] %금액표시(ARG)% 지불한다　　(현재 소지금：%금액표시(MONEY)%)
PRINTFORML [2] CM%세자리구분(ARG:1)% 지불한다　(현재 소지 카리스마：CM%세자리구분(MONEY:2)%)
$INPUT_LOOP
INPUT
SELECTCASE RESULT
	CASE 0
	CASE 1
		IF MONEY < ARG
			PRINTFORMW 돈이 부족합니다
			GOTO INPUT_LOOP
		ENDIF
		MONEY -= ARG
	CASE 2
		IF MONEY < ARG:2
			PRINTFORMW 카리스마가 부족합니다
			GOTO INPUT_LOOP
		ENDIF
		MONEY -= ARG:2
	CASEELSE
		GOTO INPUT_LOOP
ENDSELECT
RETURN RESULT
;-------------------------------------------------
;함수명 :GET_REVISION
;개요:범용 보정치 취득 함수
;인수 :ARG:0…참조하는 수치
;반환값:보정 후의 값
;비고:식중함수
;어느 수치를, 상한치에 점근 해 나가는 수치로 변환하고 싶을 때에
;상승률이 작으면 곧바로 상한에 이르는, 크면 반대로 좀처럼 상한까지 가까워지지 않는다
;-------------------------------------------------
@GET_REVISION(ARG:0, 상한, 상승률)
#FUNCTION
#DIM 상한
#DIM 상승률
RETURNF 상한 - 상승률 * 상한 / (상승률 + ARG:0)

;eg 10000,2000,20000이라면2000-2000*20000/30000

@GET_REVISION2(ARG:0, 상한, 상승률)
#FUNCTION
#DIM 상한
#DIM 상승률
RETURNF 상한 * (ARG:0 + 1) / (상승률 + ARG:0 + 1)

;-------------------------------------------------
;関数名:GET_REVISION3
;概　要:汎用補正値取得関数
;引　数:num…参照する数値　TH:0~2…しきい値1~3　
;-------------------------------------------------
@GET_REVISION3(num, TH:0, TH:1, TH:2)
#FUNCTION
#DIM TH, 3
#DIM num

FOR LOCAL,0,3
	SIF num <= TH:LOCAL || !TH:LOCAL
		RETURNF num
	;引数がTHを超えてたら超過分をSQRT*2
	num = TH:LOCAL + SQRT(num - TH:LOCAL) * 2
NEXT

RETURNF num

;10000, 50, 100, 200なら124


;-------------------------------------------------
;함수명 :PRINT_BASE
;개요:범용 보정치 취득 함수
;인수 :ARGS 바의 이름
;		ARG:0…참조하는 캐릭터 번호
;       ARG:1…베이스의 번호
;       ARG:2…바의 길이
;BAR를 표시시키고 싶을 때에
;-------------------------------------------------
@PRINT_BASE(ARGS, ARG:0, ARG:1, ARG:2)
PRINTFORM %ARGS,%
BAR BASE:ARG:(ARG:1), MAXBASE:ARG:(ARG:1), ARG:2
PRINTFORML ({BASE:ARG:(ARG:1)}/{MAXBASE:ARG:(ARG:1)})

;FileName_COMMON.ERB ------------------------------- Rev1. 00
;문자들이 라인 표시 함수
;CALL		USER
;ARG		ARGS:표시줄명, ARG:0 line_to_"-", ARG:1 라인장
;RETURN		VOID
;COMMENT	
;-----------------------------------------------------------
@DRAW_INFORMATIONLINE(ARGS, ARG, ARG:1)
#DIMS EQUAL
#DIMS MINUS
EQUAL = =
MINUS = -
LOCAL = ARG:1

IF ARGS =="Info"
	SIF TFLAG:Info표시중
		RETURN
	TFLAG:Info표시중 = 1
ENDIF
SIF !ARG:1
	LOCAL = 150
IF ARG == 1
	PRINTSINGLEFORMS "-- %ARGS% " + "%(MINUS * MAX((LOCAL - STRLENS(ARGS)), 0))%"
ELSE
	PRINTSINGLEFORMS "== %ARGS% " + "%(EQUAL * 150)%"
ENDIF
;-------------------------------------------------
;절정시 따위, A와 B와 D와…같은 느낌으로 「과」로 이어 열거하기 위한 함수
;인수에 표시하는 캐릭터라인과 조건(0으로 무효, 비0으로 유효)을 지정. 최대 5개까지
;-------------------------------------------------
@PRINT_EMUNERATE(표시:1, 조건:1, 표시:2, 조건:2, 표시:3, 조건:3, 표시:4, 조건:4, 표시:5, 조건:5)
#DIMS 표시, 6
#DIM 조건, 6

SIF 조건:1
	PRINTFORM %표시:1%
SIF 조건:1 && (조건:2 || 조건:3 || 조건:4 || 조건:5)
	PRINT 와
SIF 조건:2
	PRINTFORM %표시:2%
SIF 조건:2 && (조건:3 || 조건:4 || 조건:5)
	PRINT 와
SIF 조건:3
	PRINTFORM %표시:3%
SIF 조건:3 && (조건:4 || 조건:5)
	PRINT 와
SIF 조건:4
	PRINTFORM %표시:4%
SIF 조건:4 && 조건:5
	PRINT 와
SIF 조건:5
	PRINTFORM %표시:5%
;-------------------------------------------------
;악마로 메이드로부터 유용했습니다. 다사.
;단어1/단어2/…/단어 n 의 서식에서 쓰여진 ARGS:0~의 단어의 어떤 것인지를 등 확률로 돌려준다
;(ARGS가 다수 있는 것은 함수등이 돌진해지는 것을 상정하고 있기 (위해)때문에)
;＿(은)는 아무것도 출력하지 않는 선택으로 한다
;선택지의 수를 100까지 확장, RESULT 퇴피 처리 추가
;추첨 처리가 등 확률이라면 FOR-NEXT 사용하지 않아 좋다고 생각했으므로 RAND로 끝마친다
;-------------------------------------------------
@TEXTR(ARGS, ARGS:1, ARGS:2, ARGS:3, ARGS:4, ARGS:5, ARGS:6)
#FUNCTIONS
#DIM  L_RESULT               ;RESULT 퇴피용
#DIMS DYNAMIC CHOICES        ;결과
#DIMS DYNAMIC STR_ARRAY, 100 ;선택지 격납용의 일시 변수
L_RESULT = RESULT
;우선 1개(살)로 정리한다
ARGS = %ARGS%\/%ARGS:1%\/%ARGS:2%\/%ARGS:3%\/%ARGS:4%\/%ARGS:5%\/%ARGS:6%
;불필요한"/"을 깎는 작업
;오쿠의 ARGS가 있으면(자)//가 많이 되어있고 판정의 방해가 되므로
;1. //(은)는 치환으로 깎는다
;2. 최말미가/라면 깎는다(SPLIT와 RAND를 그대로 사용하는 형편상)
ARGS '= REPLACE(ARGS, "\/+", "/")
SIF CHARATU(ARGS, STRLENSU(ARGS) - 1) == "/"
	ARGS '= SUBSTRINGU(ARGS, 0, STRLENSU(ARGS) - 1)
SPLIT ARGS, "/", STR_ARRAY
CHOICES '= STR_ARRAY:(RAND:RESULT)
SIF CHOICES == "＿"
	CHOICES = 
RESULT = L_RESULT
RETURNF CHOICES
;-------------------------------------------------
;미독판정 함수 @ONCE
;식중에서 사용하는 함수입니다
;ARGS는 이벤트 번호, ARG는 진이라면 첫회 판정을 갱신하지 않는, ARG:1은 캐릭터등록번호(생략 하면(자) TARGET,-1라면 MASTER)
;{이벤트 번호}/　그렇다고 하는 캐릭터라인을 CSTR:1에 처넣어 갑니다
;-------------------------------------------------
@ONCE(ARGS, ARG, ARG:1)
#FUNCTION
;ARG:2의 변환
ARG:1 = ARG:1 ?  ARG:1 # TARGET
ARG:1 = ARG:1 == -1 ?  MASTER # ARG:1

SIF CSTR:(ARG:1):1 == ""
	CSTR:(ARG:1):1 = /

LOCALS = /%ARGS%/
IF STRCOUNT(CSTR:(ARG:1):1, LOCALS)
	RETURNF 0
ELSEIF ARG
	RETURNF 1
ENDIF
;첫회 판정 갱신
CSTR:(ARG:1):1 = %CSTR:(ARG:1) :1%%ARGS%/
RETURNF 1

;FileName_COMMON.ERB ------------------------------- Rev1. 00
;플래그 리셋 처리
;CALL		SYSTEM
;ARG		VOID
;RETURN		VOID
;COMMENT	
;-----------------------------------------------------------
@EVENTTRAIN
FOR LOCAL, 0, CHARANUM
	CSTR:LOCAL:1 = 
NEXT

;-------------------------------------------------
;미독판정 함수 @FIRSTTIME
;식중에서 사용하는 함수입니다.
;ARGS는 이벤트 번호, ARG는 진이라면 첫회 판정을 갱신하지 않는, ARG:1은 캐릭터등록번호(생략 하면(자) TARGET,-1라면 MASTER)
;{이벤트 번호}/　그렇다고 하는 캐릭터라인을 CSTR:0에 처넣어 갑니다
;-------------------------------------------------
@FIRSTTIME(ARGS,ARG, ARG:1)
#FUNCTION
;ARG:1의 변환
ARG:1 = ARG:1 ? ARG:1 # TARGET
ARG:1 = ARG:1 == -1 ? MASTER # ARG:1
SIF CSTR:(ARG:1):0 == ""
	CSTR:(ARG:1):0 = /

LOCALS = /%ARGS%/
IF STRCOUNT(CSTR:(ARG:1):0,LOCALS)
	RETURNF 0
ELSEIF ARG
	RETURNF 1
ENDIF
;첫회 판정 갱신
CSTR:(ARG:1):0 = %CSTR:(ARG:1):0%%ARGS%/
RETURNF 1

;-------------------------------------------------
;함수명 :EXP_UP
;개요:경험치 변동 체크
;인수 :ARG:0…참조하는 EXP
;       ARG:1…참조하는 캐릭터 번호
;-------------------------------------------------
@EXP_UP(ARG,ARG:1)
#FUNCTION
RETURNF EXP:(ARG:1):ARG - TCVAR:(ARG:1):(400 + ARG)

;-------------------------------------------------
;함수명 :INVAGINA
;개요:V에 무엇이 들어가 있는 건가를 돌려준다
;인수 :ARG:0…참조하는 캐릭터 번호
;반환값:0없음
;반환값:1 페니스
;반환값:2 바이브
;-------------------------------------------------
@INVAGINA(ARG)
#FUNCTION
IF TEQUIP:ARG:50
	IF TALENT:PLAYER:2 & 2
		RETURNF 1
	ELSE
		RETURNF 3
	ENDIF
ELSEIF TEQUIP:ARG:바이브
	RETURNF 2
ENDIF
;-------------------------------------------------
;함수명 :INANAL
;개요:A에 무엇이 들어가 있는 건가를 돌려준다
;인수 :ARG:0…참조하는 캐릭터 번호
;반환값:0없음
;반환값:1 페니스
;반환값:2 애널바이브
;반환값:3 애널비즈
;-------------------------------------------------
@INANAL(ARG)
#FUNCTION
IF TEQUIP:ARG:51
	RETURNF 1
ELSEIF TEQUIP:ARG:애널바이브
	RETURNF 2
ELSEIF TEQUIP:ARG:애널비즈
	RETURNF 3
ENDIF
;-------------------------------------------------
;함수명 :HETEROSEX
;ARG와 ARG:1의 성별이 같은가 어떤가를 돌려주는사실은 HOMOSEX이지만 어감이 나쁘기 때문에
;여성기를 가지는 것은 여자, 가지지 않는 것을 남자로 한다
;반환값0=이성
;반환값1=동성(레즈비언)
;반환값2=동성(동성애자)
;-------------------------------------------------
@HETEROSEX(ARG, ARG:1)
#FUNCTION
IF GETBIT(TALENT:ARG:2, 0) == GETBIT(TALENT:(ARG:1):2, 0)
	IF GETBIT(TALENT:ARG:2, 0)
		RETURNF 1
	ELSE
		RETURNF 2
	ENDIF
ELSE
	RETURNF 0
ENDIF

;-------------------------------------------------
;関数名:NameToID
;引数にCALLNAMEを入れるとキャラ番号を返す
;-------------------------------------------------
@NameToID(ARGS)
#FUNCTION
LOCAL = FINDCHARA(CALLNAME, @"%ARGS%" , 1)
RETURNF LOCAL


;-------------------------------------------------
;함수명 :GET_TARGETNUM
;동실중의 TARGET의 수를 돌려준다
;인수 폐지해 FOR-NEXT를 배제해 고속화
;-------------------------------------------------
@GET_TARGETNUM()
#FUNCTION
RETURNF MAX(0, FINDELEMENT(TARGET, 0) - 1)
;-------------------------------------------------
;함수명 :IN_ROOM_MEMBER
;방 중(안)에서 특정 요소에서의 최저·최고를 가지는 캐릭터를 취득
;ARGS MAX인가 MIN인지를 선택
;ARG 방의 번호
;ARGS:1 대상이 되는 변수의 이름
;ARG:1 변수의 번호
;-------------------------------------------------
@IN_ROOM_MEMBER, ARGS, ARG, ARGS:1, ARG:1
#FUNCTION
VARSET LOCAL, 0
SELECTCASE ARGS:1
	CASE "CFLAG"
		FOR LOCAL, 1, CHARANUM
			SIF CFLAG:LOCAL:현재위치 != ARG
				CONTINUE
			IF LOCAL:3++ == 0
				LOCAL:1 = CFLAG:LOCAL:(ARG:1)
				LOCAL:2 = LOCAL
			ELSEIF ARGS == "MAX" && LOCAL:1 < CFLAG:LOCAL:(ARG:1)
				LOCAL:1 = CFLAG:LOCAL:(ARG:1)
				LOCAL:2 = LOCAL
			ELSEIF ARGS == "MIN" && LOCAL:1 > CFLAG:LOCAL:(ARG:1)
				LOCAL:1 = CFLAG:LOCAL:(ARG:1)
				LOCAL:2 = LOCAL
			ELSEIF LOCAL:1 == CFLAG:LOCAL:(ARG:1) && RAND:2
				LOCAL:1 = CFLAG:LOCAL:(ARG:1)
				LOCAL:2 = LOCAL
			ENDIF
		NEXT
		RETURNF LOCAL:2
	CASE "TCVAR"
		FOR LOCAL, 1, CHARANUM
			SIF CFLAG:LOCAL:현재위치 != ARG
				CONTINUE
			IF LOCAL:3++ == 0
				LOCAL:1 = TCVAR:LOCAL:(ARG:1)
				LOCAL:2 = LOCAL
			ELSEIF ARGS == "MAX" && LOCAL:1 < TCVAR:LOCAL:(ARG:1)
				LOCAL:1 = TCVAR:LOCAL:(ARG:1)
				LOCAL:2 = LOCAL
			ELSEIF ARGS == "MIN" && LOCAL:1 > TCVAR:LOCAL:(ARG:1)
				LOCAL:1 = TCVAR:LOCAL:(ARG:1)
				LOCAL:2 = LOCAL
			ELSEIF LOCAL:1 == TCVAR:LOCAL:(ARG:1) && RAND:2
				LOCAL:1 = TCVAR:LOCAL:(ARG:1)
				LOCAL:2 = LOCAL
			ENDIF
		NEXT
		RETURNF LOCAL:2
	CASE "ABL"
		FOR LOCAL, 1, CHARANUM
			SIF CFLAG:LOCAL:현재위치 != ARG
				CONTINUE
			IF LOCAL:3++ == 0
				LOCAL:1 = ABL:LOCAL:(ARG:1)
				LOCAL:2 = LOCAL
			ELSEIF ARGS == "MAX" && LOCAL:1 < ABL:LOCAL:(ARG:1)
				LOCAL:1 = ABL:LOCAL:(ARG:1)
				LOCAL:2 = LOCAL
			ELSEIF ARGS == "MIN" && LOCAL:1 > ABL:LOCAL:(ARG:1)
				LOCAL:1 = ABL:LOCAL:(ARG:1)
				LOCAL:2 = LOCAL
			ELSEIF LOCAL:1 == ABL:LOCAL:(ARG:1) && RAND:2
				LOCAL:1 = ABL:LOCAL:(ARG:1)
				LOCAL:2 = LOCAL
			ENDIF
		NEXT
		RETURNF LOCAL:2
	CASE "TALENT"
		FOR LOCAL, 1, CHARANUM
			SIF CFLAG:LOCAL:현재위치 != ARG
				CONTINUE
			IF LOCAL:3++ == 0
				LOCAL:1 = TALENT:LOCAL:(ARG:1)
				LOCAL:2 = LOCAL
			ELSEIF ARGS == "MAX" && LOCAL:1 < TALENT:LOCAL:(ARG:1)
				LOCAL:1 = TALENT:LOCAL:(ARG:1)
				LOCAL:2 = LOCAL
			ELSEIF ARGS == "MIN" && LOCAL:1 > TALENT:LOCAL:(ARG:1)
				LOCAL:1 = TALENT:LOCAL:(ARG:1)
				LOCAL:2 = LOCAL
			ELSEIF LOCAL:1 == TALENT:LOCAL:(ARG:1) && RAND:2
				LOCAL:1 = TALENT:LOCAL:(ARG:1)
				LOCAL:2 = LOCAL
			ENDIF
		NEXT
		RETURNF LOCAL:2
ENDSELECT
;FileName_COMMON.ERB ------------------------------- Rev1. 00
;TARGET재설정 함수
;CALL		USER
;ARG		VOID
;RETURN		VOID
;COMMENT	
;-----------------------------------------------------------
;
;리스트 함수와 소트 함수가 생겼으므로 꽤 간이화 할 수 있었는지
@TARGETSET_CHACK(OP)
#DIMS OP         ;SHOW_STATUS는 동실 갱신 들어갈 수 있으면(자) 좋지 않아의로 스킵 하는 용
#DIM  TARGET_CNT ;타겟의 수
#DIM  L_ID       ;REF 대책, 건네줄 뿐
#DIM  SWAP_ID    ;현재의TARGET 지정 처리용의 일시 변수
;우후후 안은 TARGET를 놓친다(정사 발각등으로 어긋나버린다 것으로)
SIF !TFLAG:현재의TARGET
	TFLAG:현재의TARGET = TARGET

CALL MAKE_CHARA_LIST("TARGET 리스트", L_ID, TARGET, TARGET_CNT)
SIF !TARGET_CNT
	RETURN
CALL SORT_LIST("호감 내림차순", TARGET, TARGET_CNT)

LOCAL:1 = TARGET
IF TFLAG:현재의TARGET > 0
	LOCAL:1 = FINDELEMENT(TARGET, TFLAG:현재의TARGET)
	IF LOCAL:1 == -1
		LOCAL:1 = 0
		TFLAG:현재의TARGET = 0
	ENDIF
	LOCAL:1 = TARGET:(LOCAL:1)
ENDIF
ARRAYSHIFT TARGET, 1, LOCAL:1
[SKIPSTART]
SIF STRCOUNT(OP, "「동실 갱신 없음」")
	RETURN

;동실 확인은 리스트측에서 하고 있으므로 여기에서는 필요없다
FOR LOCAL, 1, 1 + TARGET_CNT
	CFLAG:(TARGET:LOCAL):동실 = 1
NEXT
[SKIPEND]





;====================================================
@성기술보정(ARG)
#FUNCTION
RETURNF 1 + (ABL:PLAYER:ARG - 2) / 10
;====================================================

;-------------------------------------------------
;함수명 :RECOVER
;개요:BASE 회복 처리
;		표시 문자열이 빈 경우 회복량이 100 미만 숨김
;		표시 문자열이 있는 경우 표시
;인수 :ARG:0	참조하는 캐릭터 번호
;		회복량	ARGS에 대응하는 BASE에 가산하는 값(음수의 경우는 줄임)
;       ARGS	베이스명
;		ARGS:1	표시문자열
;-------------------------------------------------
@RECOVER(ARG,회복량,ARGS,ARGS:1)
#DIM BASE_ID
#DIM 회복량
SIF 회복량 == 0 || !CHECKE_BASE(ARG, ARGS)
	RETURN
;회복처리
BASE:ARG:(ARGS) = LIMIT(BASE:ARG:(ARGS) + 회복량, 0, MAXBASE:ARG:(ARGS))
;표시처리
SIF 회복량 > 0 && 회복량 < 100 && ARGS:1 == ""
	RETURN
IF CFLAG:ARG:현재위치 == CFLAG:MASTER:현재위치
	BASE_ID = FINDELEMENT(BASENAME, ARGS)
	LOCALS = \@ ARGS:1 != "" ? （%ARGS:1%） # \@
	IF 회복량 > 0
		CALL COLORMESSAGE(@"%BASENAME:BASE_ID%＋{회복량} （%CALLNAME:ARG%）%LOCALS%",C_GREEN,1)
	ELSEIF 회복량 < 0
		CALL COLORMESSAGE(@"%BASENAME:BASE_ID%－{ABS(회복량)} （%CALLNAME:ARG%）%LOCALS%",C_RED,1)
	ENDIF
ENDIF

;-------------------------------------------------
;함수명 :RECOVER_PERMIL
;개요:BASE 비율 회복 처리
;인수 :ARG:0		참조하는 캐릭터 번호
;		회복비율	MAXBASE에 대해 산출하는 값(음수인 경우에는 줄임)
;       ARGS		베이스명
;       회복속도의영향	
;		ARGS:1		표시문자열
;회복비율은 0.1% 단위
;-------------------------------------------------
@RECOVER_PERMIL(ARG,회복비율,ARGS,회복속도의영향,ARGS:1="")
#DIM 회복비율
#DIM 회복속도의영향
#DIM 회복량
SIF !CHECKE_BASE(ARG, ARGS)
	RETURN
회복량 = MAXBASE:ARG:(ARGS) * 회복비율 / 1000
SIF 회복속도의영향
	회복량 = 회복량 * (TALENT:ARG:회복속도 + 4) / 4
CALL RECOVER(ARG, 회복량, ARGS, ARGS:1)
;-------------------------------------------------
;함수명:RECOVER_PERMIL_BOTH
;개　요:RECOVER_PERMIL를 당신과 대상 캐릭터 둘 다 실행
;-------------------------------------------------
@RECOVER_PERMIL_BOTH(ARG,회복비율,ARGS,회복속도의영향,ARGS:1="")
#DIM 회복비율
#DIM 회복속도의영향
CALL RECOVER_PERMIL(ARG,회복비율,ARGS,회복속도의영향,ARGS:1)
SIF ARG != MASTER
	CALL RECOVER_PERMIL(MASTER,회복비율,ARGS,회복속도의영향,ARGS:1)

;-------------------------------------------------
;함수명:CHECKE_BASE
;개요  :ARG를 사용할 수 있는 BASE인지 판정
;반환값:0：사용불가
;		1：사용가능
;-------------------------------------------------
@CHECKE_BASE(ARG, ARGS)
#FUNCTION
SELECTCASE ARGS
	; 한판 임의수정, 번역 누락에 의한 오류 방지를 위해 원문/변역 병기
	CASE "체력", "기력", "体力", "気力"
	;竿なしならスキップ
	CASE "정력", "발기", "사정", "精力", "勃起", "射精"
		SIF !HAS_PENIS(ARG)
			RETURNF 0
	;あなた以外TSPスキップ
	CASE "TSP"
		SIF ARG != MASTER
			RETURNF 0
	CASE "모유", "母乳"
		SIF !TALENT:ARG:모유체질
			RETURNF 0
ENDSELECT
RETURNF 1


;-------------------------------------------------
;함수명 :BUFF_BASE
;개요:특정 BASE를 일시적으로 강화
;-------------------------------------------------
@BUFF_BASE(ARG, 강화능력, 변동치, 메시지)
#DIM 변동치
#DIM 강화능력
#DIM 메시지
SIF !CHECKE_BASE(ARG, BASENAME:강화능력)
	RETURN
SIF 변동치 < 0 && ABS(변동치) > MAXBASE:ARG:강화능력
	변동치 = (MAXBASE:ARG:강화능력 - 1) * -1

MAXBASE:ARG:강화능력 += 변동치
BASE:ARG:강화능력 += 변동치
BUFF:ARG:강화능력 += 변동치
SIF 메시지
	CALL COLORMESSAGE(@"%CALLNAME:ARG%의 %조사처리(BASENAME:강화능력,"이")% 일시적으로 {ABS(변동치)} \@ 변동치 > 0?  올랐다# 내려갔다\@", C_YELLOW, 1)
;-------------------------------------------------
;함수명 :BUFF_RESET
;개요:버프를 완전하게 리셋
;-------------------------------------------------
@BUFF_RESET
FOR LOCAL, 0, CHARANUM
	FOR LOCAL:1, 0, 16
		MAXBASE:LOCAL:(LOCAL:1) -= BUFF:LOCAL:(LOCAL:1)
		BASE:LOCAL:(LOCAL:1) -= BUFF:LOCAL:(LOCAL:1)
		BUFF:LOCAL:(LOCAL:1) = 0
	NEXT
NEXT

;-------------------------------------------------
;함수명 :CHANGE_CFLAG
;개요:메시지 첨부 CFLAG 변동
;마이나스는 되지 않게 되고 있기 때문에 주의
;-------------------------------------------------
@CHANGE_CFLAG(변동플래그, 대상, 변동수)
#DIM 변동플래그
#DIM 대상
#DIM 변동수
변동수=변동수*(1+FLAG:의뢰호감신뢰상승률)
CFLAG:대상:변동플래그 = MAX(CFLAG:대상:변동플래그 + 변동수, 0)
IF 변동수 > 0
	CALL COLORMESSAGE(@"%CFLAGNAME:변동플래그%＋{변동수}(%CALLNAME:대상%)", C_YELLOW, 2,1)
ELSE
	CALL COLORMESSAGE(@"%CFLAGNAME:변동플래그%－{-변동수}(%CALLNAME:대상%)", C_RED, 2,1)
ENDIF

;-------------------------------------------------
;함수명: AddEXP
;개요: 메세지 첨부 EXP 가산
;マイナスにはならないようになってるので注意
;-------------------------------------------------
@AddEXP(VAR_NAME,C_ID,변수)
#DIMS VAR_NAME
#DIM VAR_ID
#DIM C_ID
#DIM 변수

SIF 변수 == 0
	RETURN

VAR_ID = FINDELEMENT(EXPNAME, VAR_NAME)
EXP:C_ID:VAR_ID += 변수
CALL COLORMESSAGE(@"%VAR_NAME%＋{변수}（%CALLNAME:C_ID%）",C_YELLOW,2,1)

;-------------------------------------------------
;함수명 :SHIRAHU
;개요:보통으로 의식이 있는 상태인가　2라면 우후후중
;-------------------------------------------------
@SHIRAHU(ARG)
#FUNCTION
IF FLAG:70
	RETURNF 0
ELSEIF !CFLAG:ARG:수면 && !CFLAG:ARG:동침중 && !TCVAR:ARG:만취 && !CFLAG:ARG:쇠약
	IF TFLAG:102 == 2
		RETURNF 2
	ELSE
		RETURNF 1
	ENDIF
ELSE
	RETURNF 0
ENDIF

;-------------------------------------------------
;함수명 :BETWEENTIME
;개요:TIME가 ARG로부터 ARG:1까지의 사이인가 돌려주는 함수
;-------------------------------------------------
@BETWEENTIME(ARG, ARG:1)
#FUNCTION
IF ARG < ARG:1
	IF TIME >= ARG && TIME < ARG:1
		RETURNF 1
	ELSE
		RETURNF 0
	ENDIF
ELSE
	IF TIME >= ARG || TIME < ARG:1
		RETURNF 1
	ELSE
		RETURNF 0
	ENDIF
ENDIF
;-------------------------------------------------
;함수명 :VISIT
;개요:그 캐릭터의 활동시간대인가 어떤가를 돌려주는 함수
;-------------------------------------------------
@VISIT(ARG)
#FUNCTION
RETURNF BETWEENTIME(CFLAG:ARG:내방시간, CFLAG:ARG:귀가시간)
;-------------------------------------------------
;함수명:수면시간
;개요:더부살이캐릭터가 자고 있어 어떤가를 돌려주는 함수였던 것을 전원 사용할 수 있도록(듯이)
;자고 있다고(면) 1을 돌려준다
;-------------------------------------------------
@수면시간(ARG)
#FUNCTION
SIF ARG == MASTER
	RETURNF CFLAG:MASTER:수면
IF CFLAG:ARG:쇠약
	RETURNF 1
ELSE
	;수면 시간을 체크한다
	CALLF 수면시간２(ARG)
	IF !BETWEENTIME(CFLAG:ARG:기상시간, CFLAG:ARG:취침시간 + CFLAG:ARG:졸음쫒기강도)
		RETURNF 1
	ELSE
		RETURNF 0
	ENDIF
ENDIF
;-------------------------------------------------
;함수명:수면시간２
;개요:캐릭터 ARG가 잠들고 일어날 때까지의 시간 측정
;일탈하고 있었을 경우는 자동으로 수정한다
;-------------------------------------------------
@수면시간２(ARG)
#FUNCTION
#DIM SLEEPTIME
#DIM WAKEUPTIME
;졸음쫒기강도만큼 연장한다
WAKEUPTIME = CFLAG:ARG:기상시간
SLEEPTIME = CFLAG:ARG:취침시간 + CFLAG:ARG:졸음쫒기강도
;취침시간이 24시를 넘을 경우
WHILE SLEEPTIME >= 1440
	SLEEPTIME -= 1440
WEND
;전날 밤에 자고 다음날 아침에 일어나는 경우
SIF SLEEPTIME > WAKEUPTIME
	WAKEUPTIME += 1440
;수면시간이 2~14시간 이상이면 체크
IF !INRANGE(WAKEUPTIME - SLEEPTIME, 0, 840)
	;졸음쫒기강도가 원인
	IF CFLAG:ARG:졸음쫒기강도
		;30분 단위로 시정해간다
		CFLAG:ARG:졸음쫒기강도 -= 30
		RESTART
	;설정이 이상할 때
	ELSE
		[IF_DEBUG]
			;체크를 위해 THROW 해두기, 모브코는 허가, 一時的に守矢くじ対策,あとで修正,THROWはアレなのでデバッグ用に
			SIF ARG != [[모브코]] && CFLAG:ARG:기상시간 != CFLAG:ARG:취침시간
				THROW
		[ENDIF]
		ENDIF
ENDIF
RETURNF WAKEUPTIME - SLEEPTIME	

;-------------------------------------------------
;캐릭터의 생활시간을 설정하는 함수
;하루의 시작에 설정하기
;-------------------------------------------------
@생활시간설정(CHARA)
#DIM CHARA
CALLFORM CHARAMOVE_DATA_{CHARA}(3)
CFLAG:CHARA:기상시간 = 시각계산(CSVCFLAG(CHARA, GETNUM(CFLAG, "기상시간")) + CFLAG:CHARA:생활시간보정)
CFLAG:CHARA:내방시간 = 시각계산(CSVCFLAG(CHARA, GETNUM(CFLAG, "내방시간")) + CFLAG:CHARA:생활시간보정)
CFLAG:CHARA:귀가시간 = 시각계산(CSVCFLAG(CHARA, GETNUM(CFLAG, "귀가시간")) + CFLAG:CHARA:생활시간보정)
CFLAG:CHARA:취침시간 = 시각계산(CSVCFLAG(CHARA, GETNUM(CFLAG, "취침시간")) + CFLAG:CHARA:생활시간보정)
;大晦日はみんな夜ふかし
IF FESTIVAL() == "그믐날"
	IF INRANGE(CFLAG:CHARA:귀가시간, 900 , 1440) || INRANGE(CFLAG:CHARA:귀가시간, 0 , 59) || INRANGE(CFLAG:CHARA:취침시간, 900 , 1440) || INRANGE(CFLAG:CHARA:취침시간, 0 , 119)
		CFLAG:CHARA:귀가시간 = 60
		CFLAG:CHARA:취침시간 = 120
	ENDIF
ENDIF
;-------------------------------------------------
;시각의 계산
;시각X+Y를 시각으로 반환한다
;-------------------------------------------------
@시각계산(ARG)
#FUNCTION
LOCAL = ARG
WHILE LOCAL > 1440
	LOCAL -= 1440
WEND
WHILE LOCAL < 0
	LOCAL += 1440
WEND
RETURNF LOCAL

;-------------------------------------------------
;함수명:아이의수면시간
;개요:캐릭터 ARG의 아이가 자고 있어 어떤가를 돌려주는 함수
;자고 있다고(면) 1을 돌려준다
;-------------------------------------------------
@아이의수면시간(ARG)
#FUNCTION
#DIM 아이의기상시간
#DIM 아이의취침시간
SIF !TALENT:ARG:육아중
	RETURNF 0
아이의기상시간 = CFLAG:ARG:기상시간
아이의취침시간 = CFLAG:ARG:취침시간 - 120 + (CFLAG:ARG:취침시간 - 120 < 0 ?  1440 # 0 )
IF !BETWEENTIME(아이의기상시간, 아이의취침시간)
	RETURNF 1
ELSE
	RETURNF 0
ENDIF
;-------------------------------------------------
;함수명 :WORKING
;개요:그 캐릭터의 일시간대인가 어떤가를 돌려주는 함수
;-------------------------------------------------
@WORKING(ARG)
#FUNCTION
IF !SHIRAHU(ARG)
	RETURNF 0
ELSEIF !BETWEENTIME(TCVAR:ARG:일개시, TCVAR:ARG:일종료)
	RETURNF 0
ELSEIF BASE:ARG:일량 <= 0
	RETURNF 0
ELSEIF CHARA_HOLIDAY(ARG)
	RETURNF 0
ELSE
	RETURNF 1
ENDIF
;-------------------------------------------------
;함수명:연속실행
;개요:동일 커맨드 연속실행했을 때 패널티가 발생할까
;반환값:0이라면 페나가 발생하지 않는다
;-------------------------------------------------
@연속실행()
#FUNCTION
SIF TARGET != TFLAG:103
	RETURNF 0
SELECTCASE PREVCOM
	CASE 1,60,61,65,67,68,300,304,410,442,445,446,604,621
		RETURNF 0
	CASEELSE
		RETURNF 1
ENDSELECT

;-------------------------------------------------
;함수명:카운터우타즈커맨드
;반환값:0이 아니면 카운터 우타즈
;-------------------------------------------------
@카운터우타즈커맨드(ARG)
#FUNCTION
SELECTCASE ARG
	CASE 697 TO 699
		RETURNF 1
	CASEELSE
		RETURNF 0
ENDSELECT
;-------------------------------------------------
;함수명 :ENDUFUFU
;개요:우후후 종료시 리셋 처리
;-------------------------------------------------
@ENDUFUFU(ARG)
TCVAR:ARG:임시생해금 = 0
IF FLAG:개인실입장
	CFLAG:(FLAG:개인실입장):현재위치 = 1570
	FLAG:개인실입장 = 0
	IF 척살대상창녀
		CFLAG:(척살대상창녀):현재위치 = 1599
		CFLAG:(척살대상창녀):출금 = 2
		척살대상창녀 = 0
	ENDIF
ENDIF
[IF_DEBUG]
	PRINTFORML 우후후 종료 처리
[ENDIF]
UFUFU_START_TIME = 0
UFUFU_START_DAY = 0
;시간정지중은 복장 세트 하지 않는다
;수면 절반으로 자르는 것기 등은 모두 리셋 처리 곁에 있습니다
IF !CFLAG:강제탈의
	SIF !FLAG:시간정지
		CALL CHANGE_CLOTHES(ARG, "의상 리셋")
	;복장을 TEQUIP에
	CALL CLOTHES_SETTING_TRAIN(ARG)
	
ENDIF
;MASTERとの接触位置をリセット
CALL TOUCH_SET(0, 0, 0, 1)

;우후후시 계 장비 리셋
;TEQUIP:ARG:10-TEQUIP:ARG:149를 초기화한다
VARSET TEQUIP:ARG:0, 0, 10, 150

;사정 관계 리셋
IF TFLAG:102 < 2
	BASE:ARG:사정 = 0
	TCVAR:ARG:이기초 = 0
ENDIF
CFLAG:ARG:우후후 = 0
TEQUIP:ARG:50 = -1
TEQUIP:ARG:51 = -1
IF !CFLAG:강제탈의
	TEQUIP:ARG:상반신탈의상태 = 0
	TEQUIP:ARG:하반신비켜놓기상태 = 0
	TEQUIP:ARG:윗도리탈의가끝난상태 = 0
ENDIF
TCVAR:ARG:억지로 = 0
TCVAR:ARG:마음대로해 = 0
TCVAR:ARG:레이프중 = 0
TCVAR:ARG:역레이프 = 0
;일단 MASTER도 초기화(해 두지 않으면 종료후도00장착중이 표시될 가능성이 있으므로
IF CFLAG:MASTER:우후후
	CFLAG:MASTER:우후후 = 0
	CALL CHANGE_CLOTHES(MASTER, "의상 리셋")
	CALL CLOTHES_SETTING_TRAIN(MASTER)
	VARSET TEQUIP:MASTER:0, 0, 10, 150
	TEQUIP:MASTER:50 = -1
	TEQUIP:MASTER:51 = -1
	TEQUIP:MASTER:상반신탈의상태 = 0
	TEQUIP:MASTER:하반신비켜놓기상태 = 0
ENDIF

IF CFLAG:수면
	IF CFLAG:ARG:구내정액
		PRINTFORML %마스터는% %CALLNAME:ARG%의 입 안에 남아있던 정액을 처리했다
		CFLAG:ARG:구내정액 = 0
	ENDIF
	IF CFLAG:ARG:안면정액 || CFLAG:ARG:손에정액
		PRINTFORM %마스터는% %CALLNAME:ARG%의 
		IF CFLAG:ARG:안면정액 && !CFLAG:ARG:손에정액
			PRINTFORM 얼굴에 묻은 
		ELSEIF !CFLAG:ARG:안면정액 && CFLAG:ARG:손에정액
			PRINTFORM 손에 묻은 
		ELSE
			PRINTFORM 얼굴과 손을 더럽힌 
		ENDIF
		PRINTFORML 정액을 닦았다
		CFLAG:ARG:안면정액 = 0
		CFLAG:ARG:손에정액 = 0
	ENDIF
ENDIF
IF !FLAG:시간정지
	TFLAG:운반 = 0
	IF CFLAG:ARG:구내정액
		PRINTFORML %CALLNAME:ARG%는 입 안에 남아있던 정액을 \@ ABL:ARG:정액중독 > 2 ?  전부 삼켰다 # 뱉었다 \@
		CFLAG:ARG:구내정액 = 0
	ENDIF
	IF CFLAG:ARG:안면정액 || CFLAG:ARG:손에정액
		PRINTFORM %CALLNAME:ARG%는 
		IF CFLAG:ARG:안면정액 && !CFLAG:ARG:손에정액
			PRINTFORM 얼굴에 묻은 
		ELSEIF !CFLAG:ARG:안면정액 && CFLAG:ARG:손에정액
			PRINTFORM 손에 묻은 
		ELSE
			PRINTFORM 얼굴과 손을 더럽힌 
		ENDIF
		PRINTFORML 정액을 \@ ABL:ARG:정액중독 > 2 ?  입에 넣었다 # 닦았다 \@
		CFLAG:ARG:안면정액 = 0
		CFLAG:ARG:손에정액 = 0
	ENDIF
ENDIF

;잠복モード解除
SIF GETBIT(FLAG:잠복,0)
	CALL 잠복모드종료처리

;-------------------------------------------------
;関数名:ENDUFUFU_ALL
;概　要:全員にENDUFUFU
;人数を返す
;-------------------------------------------------
@ENDUFUFU_ALL
VARSET LOCAL
FOR LOCAL, 0, CHARANUM
	IF CFLAG:LOCAL:우후후
		CALL ENDUFUFU(LOCAL)
		LOCAL:1 ++
	ENDIF
NEXT
TFLAG:MASTER의P삽입중 = 0
RETURN LOCAL:1


;-------------------------------------------------------------
;ARG와 당신이 동성이었던 경우, 양자에게 레즈비언(동성애자) 경험을 추가하는 함수
;-------------------------------------------------------------
@ADD_EXP_LESNIAN(UP_EXP, ARG, ARGS)
#DIM UP_EXP
#DIM SAMESEX

;제2 인수를 생략 하면(자) TARGET 취급
SIF !ARG
	ARG = TARGET
IF HETEROSEX(ARG, MASTER)
	SAMESEX = 50 + HETEROSEX(ARG, MASTER)
	EXP:SAMESEX += UP_EXP
	EXP:PLAYER:SAMESEX += UP_EXP
	IF ARGS != ""
		CALL COLORMESSAGE(@"%EXPNAME:SAMESEX%＋{UP_EXP}(%CALLNAME:ARG%)", C_YELLOW, 2,1)
		CALL COLORMESSAGE(@"%EXPNAME:SAMESEX%＋{UP_EXP}(%CALLNAME:MASTER%)", C_YELLOW, 2,1)
	ENDIF
ENDIF

;----------------------------------------------------
;성별 판정용
;----------------------------------------------------
@HAS_PENIS(ARG)
#FUNCTION
SIF GETBIT(TALENT:ARG:성별, 1)
	RETURNF 1
RETURNF 0

;-------------------------------------------------
;이벤트등으로 이성을 잃었을 경우의 처리
;-------------------------------------------------
@GET_ANGRY(ARG, 각인부여)
#DIM 각인부여

CFLAG:ARG:언짢음 = 1
CFLAG:ARG:빡침 = 1
BASE:ARG:분노 = MAXBASE:ARG:분노
TALENT:ARG:기분 = -1
MARK:ARG:반발각인 = MIN(MARK:ARG:반발각인 + 각인부여, 3)
MARK:ARG:반발취득이력 = MAX(MARK:ARG:반발취득이력, MARK:ARG:반발각인)

;FileName_COMMON.ERB ------------------------------- Rev1. 00
;술에 취함 상태 취득
;CALL		USER
;ARG		캐릭터 No
;RETURN		술에 취함 상태 _toSTR
;COMMENT	
;-----------------------------------------------------------
@ALCOHOL_FACE(ARG)
#FUNCTIONS
SIF BASE:ARG:술기운 <= 2
	RETURNF "　맨정신　"
SELECTCASE BASE:ARG:술기운
	CASE IS > (MAXBASE:ARG:술기운 / 10) * 8
		RETURNF "곤드레만드레"
;	CASE IS > (MAXBASE:ARG:술기운 / 10) * 7
;		RETURNF "고주망태"
	CASE IS > (MAXBASE:ARG:술기운 / 10) * 5
		RETURNF "주정꾼"
	CASE IS <= (MAXBASE:ARG:술기운 / 10) * 5
		RETURNF "취기"
ENDSELECT
;-------------------------------------------------
;네/아니오의 선택지를 표시해 입력 결과를 돌려주는 함수
;인수 0=긍정 선택지의 캐릭터라인,1=부정 선택지의 캐릭터라인
;반환값 0=네,1=아니오
;-------------------------------------------------
@ASK_YN(ARGS:0 = "　네　", ARGS:1 = "아니오")
CURRENTREDRAW
LOCAL:0 = RESULT
REDRAW 0
PRINTBUTTON @" [%ARGS:0%]", 0
PRINTL
PRINTBUTTON @" [%ARGS:1%]", 1
PRINTL 
$INPUT_LOOP
INPUT
IF RESULT != 0 && RESULT != 1
	CLEARLINE 1
	GOTO INPUT_LOOP
ENDIF
REDRAW LOCAL:0
RETURN RESULT
;-------------------------------------------------
;특수한 기능을 가지는 버튼을 작성하는 함수
;ARG는 입력되는 숫자, ARG:1에 1을 설정하면(자) 회색에,
;ARG:2에 1을 설정하면(자) 버튼이 황색, ARG:3에 1을 설정하면(자) 버튼이 무효(회색)
;-------------------------------------------------
@PRINTBUTTON_EX(ARGS:0, ARG, ARG:1, ARG:2, ARG:3)
IF ARG:3
	SETCOLOR C_L_GRAY
	PRINTFORM %ARGS:0%
ELSE
	SIF ARG:2
		SETCOLOR C_YELLOW
	SIF ARG:1
		SETCOLOR C_L_GRAY
	PRINTBUTTON @"%ARGS:0%", ARG
ENDIF
RESETCOLOR
;-------------------------------------------------
;특수한 기능을 가지는 버튼을 작성하는 함수
;ARG는 입력되는 숫자, ARG:1에 1을 설정하면(자) 회색에,
;ARG:2에 1을 설정하면(자) 버튼이 황색, ARG:3에 1을 설정하면(자) 버튼이 무효(회색)
;-------------------------------------------------
@PRINTBUTTON_EXC(ARGS:0, ARG, ARG:1, ARG:2, ARG:3)
IF ARG:3
	SETCOLOR C_L_GRAY
	PRINTFORMC %ARGS:0%
ELSE
	SIF ARG:2
		SETCOLOR C_YELLOW
	SIF ARG:1
		SETCOLOR C_L_GRAY
	PRINTBUTTONC @"%ARGS:0%", ARG
ENDIF
RESETCOLOR
;-------------------------------------------------
;Fisher-Yates 알고리즘에 의한 셔플 배열의 작성
;전용 배열 SHAFFLE_ARRAY를 사용
;인수 0:배열의 길이(0~ARG:0-1까지의 셔플) 
;-------------------------------------------------
@FISHER_YATES_SHAFFLE(ARG:0)
;셔플 배열의 초기화
SIF !INRANGE(ARG:0 , 1 , 999)
	THROW 인수({ARG:0})가 이상합니다. 1~999의 범위에서 지정해 주세요.
VARSET SHAFFLE_ARRAY , 0
;SHAFFLE_ARRAY의 초기화
FOR LOCAL:0 , 0 , ARG:0
	SHAFFLE_ARRAY:(LOCAL:0) = LOCAL:0
NEXT

FOR LOCAL:0 , 0 , ARG:0 - 1
	LOCAL:1 = RAND(LOCAL:0 , ARG:0)
	SWAP SHAFFLE_ARRAY:(LOCAL:0), SHAFFLE_ARRAY:(LOCAL:1)
NEXT
;종단용으로―1을 세트
SHAFFLE_ARRAY:(ARG:0) = -1
RETURN 0

@NEMUKE()
#FUNCTION
LOCAL =  TIME + 1440 * DAY - TFLAG:당신기상 - TFLAG:198 - CFLAG:MASTER:385 + (TCVAR:MASTER:수면제강도 * 200)
RETURNF LOCAL

;-------------------------------------------------
;시각표시(ARG)
;주어진 TIME를 H시 MM분 표시에 변환
;-------------------------------------------------
@시각표시(ARG)
#FUNCTIONS
#DIM HOUR
#DIM MINUTE
#DIMS 시각
HOUR   = ARG / 60
MINUTE = ARG % 60
시각 = %TOSTR(HOUR)%시 %TOSTR(MINUTE,"00")%분
RETURNF 시각

;-------------------------------------------------
;시각 변환(HOUR, MINUTE)
;주어진 HOUR시 MINUTE분을 TIME용으로 변환
;만약을 위해 HOUR가 25였거나 MINUTE가 61이기도 했을 경우에도 대응했다
;예) CLOCK_TO_TIME(10, 0)를 하면(자) 돌아가는 수치는 600
;eraTW의 하루는00:01~24:00의 범위, 자세하게는@INFO_GO_NEXTDAY를 봐라
;-------------------------------------------------
@CLOCK_TO_TIME(HOUR, MINUTE)
#FUNCTION
#DIM HOUR
#DIM MINUTE
SIF HOUR == 24 && MINUTE == 0
	RETURNF 24 * 60
HOUR   = (HOUR + MINUTE / 60) % 24
MINUTE = MINUTE % 60
RETURNF HOUR * 60 + MINUTE



;-------------------------------------------------
;TIMESTOP(ARG)
;그 캐릭터의 시간정지 상태를 돌려준다
;0=시간정지 없음(의식 있어)　1=시간정지 세계 진입(의식 있어)　2=완전하게 제지당하고 있다(의식이 없는 상태)
;-------------------------------------------------
@TIMESTOP(ARG)
#FUNCTION
;인수를 생략하면(자) TARGET
SIF !ARG
	ARG = TARGET
IF !FLAG:70
	LOCAL = 0
ELSEIF CFLAG:ARG:344 == 1
	LOCAL = 1
ELSE
	LOCAL = 2
ENDIF
RETURNF LOCAL

@KIGEN_CHANGE(ARG, 확률, 경향)
#DIM 확률
#DIM 경향
;경향을 1으로 하면(자)+마셔,-1로 하면(자)-마셔
SIF TALENT:ARG:감정결여
	확률 /= 2
IF RAND:100 < 확률
	IF !경향
		IF !RAND:2
			TALENT:ARG:기분 ++
		ELSE
			TALENT:ARG:기분 --
		ENDIF
	ELSE
		TALENT:ARG:기분 += 경향
	ENDIF
ENDIF
TALENT:ARG:기분 = LIMIT(TALENT:ARG:기분,-1, 1)

;-------------------------------------------------
;ARG가 남성기피로 당신이 남자라면 1
;ARG가 여성기피로 당신이 여자라면 2를 돌려준다
;연모 애욕 양도로 무효
;-------------------------------------------------
@OTOKOGIRAI(ARG)
#FUNCTION
;양도
SIF TALENT:ARG:성별기호 == -1
	RETURNF 0
;연모
SIF TALENT:ARG:연모
	RETURNF 0
SIF TALENT:ARG:애욕
	RETURNF 0
;남성기피
IF TALENT:ARG:성별기호 & 1 && !(TALENT:PLAYER:2 & 1)
	RETURNF 1
;여성기피
ELSEIF TALENT:ARG:성별기호 & 2 && !(TALENT:PLAYER:2 & 2)
	RETURNF 2
ENDIF
RETURNF 0



;-------------------------------------------------
;정욕감지의 개별 판정 F함수
;-------------------------------------------------
;실적 해제하지 않아도 짐작 할 수 있도록(듯이)
;커맨드로서의 정욕감지는 사용 불가능
@NOTICE_LUST(C_ID)
#FUNCTION
#DIM C_ID
SIF C_ID == MASTER
	RETURNF 0
SIF TALENT:MASTER:정욕감지
	RETURNF 1
SIF EXP:C_ID:데이트경험 + EXP:C_ID:애정경험 >= 100
	RETURNF 1
RETURNF 0



;-------------------------------------------------
;생리주기가시화의 개별 판정 F함수
;-------------------------------------------------
;실적 해제하지 않아도 가시화할 수 있도록(듯이)
@NOTICE_CYCLE(C_ID)
#FUNCTION
#DIM C_ID
SIF !GETBIT(TALENT:C_ID:성별, 0)
	RETURNF 0
;자신의 것은 파악해와
SIF C_ID == MASTER
	RETURNF 1
SIF FLAG:생리주기가시화
	RETURNF 1
SIF EXP:C_ID:데이트경험 + EXP:C_ID:애정경험 >= 200
	RETURNF 1
RETURNF 0



;-------------------------------------------------
;캐릭터 체크 F함수
;-------------------------------------------------
;캐릭터가 특정 조건에 합치하고 있는지 어떤지를 돌려준다
;조건은 TYPE 마다 지정
;복합한 조건에 이름을 붙일 때는 캐릭터리스트클래스 함수를 증설하기로 했다
;-------------------------------------------------
@CHECK_CHARA(C_ID, TYPE = "존재")
#FUNCTION
#LOCALSIZE 1
#LOCALSSIZE 1
#DIMS DYNAMIC TYPE ;판정 타입, DYNAMIC 했으므로 다중 호출 가능
#DIM C_ID          ;등록 번호
SELECTCASE TYPE
;기본 조건
CASE "존재", "存在"
	RETURNF !CFLAG:C_ID:출금
CASE "함락", "陥落"
	RETURNF (TALENT:C_ID:사모 || TALENT:C_ID:연모 || TALENT:C_ID:애욕 || TALENT:C_ID:연인 || TALENT:C_ID:섹프)
CASE "인간", "人間"
	RETURNF TALENT:C_ID:인간
CASE "선인", "仙人"
	RETURNF GET_TRIBENAME(C_ID, GETNUM(TALENT, "인간")) == "선인"
CASE "천인", "天人"
	RETURNF GET_TRIBENAME(C_ID, GETNUM(TALENT, "인간")) == "천인"
CASE "월인", "月人"
	RETURNF GET_TRIBENAME(C_ID, GETNUM(TALENT, "인간")) == "월인"
CASE "마계인", "魔界人"
	RETURNF GET_TRIBENAME(C_ID, GETNUM(TALENT, "인간")) == "마계인"
CASE "외계인", "外界人"
	RETURNF GET_TRIBENAME(C_ID, GETNUM(TALENT, "인간")) == "외계인"
CASE "요괴", "妖怪"
	RETURNF TALENT:C_ID:요괴
CASE "오니", "鬼"
	RETURNF GROUPMATCH(GET_TRIBENAME(C_ID, GETNUM(TALENT, "요괴")), "오니", "흡혈귀")
CASE "흡혈귀", "吸血鬼"
	RETURNF GET_TRIBENAME(C_ID, GETNUM(TALENT, "요괴")) == "흡혈귀"
CASE "캇파", "河童"
	RETURNF GET_TRIBENAME(C_ID, GETNUM(TALENT, "요괴")) == "캇파"
CASE "텐구", "天狗"
	RETURNF GET_TRIBENAME(C_ID, GETNUM(TALENT, "요괴")) == "텐구"
CASE "요수", "妖獣"
	RETURNF GROUPMATCH(GET_TRIBENAME(C_ID, GETNUM(TALENT, "요괴")), "요수", "요조", "요충")
CASE "요정", "妖精"
	RETURNF TALENT:C_ID:요정
CASE "신령", "神霊"
	RETURNF TALENT:C_ID:신령
CASE "유령", "幽霊"
	RETURNF TALENT:C_ID:유령
CASE "츠쿠모가미", "付喪神"
	RETURNF TALENT:C_ID:츠쿠모가미
CASE "인형", "人形"
	RETURNF TALENT:C_ID:인형
CASE "무녀", "巫女"
	RETURNF GET_TRIBENAME(C_ID, GETNUM(TALENT, "추가종족")) == "무녀"
CASE "마법사", "魔法使い"
	RETURNF GET_TRIBENAME(C_ID, GETNUM(TALENT, "추가종족")) == "마법사"
CASE "메이드", "メイド"
	RETURNF GET_TRIBENAME(C_ID, GETNUM(TALENT, "추가종족")) == "메이드"
CASE "봉래인", "蓬莱人"
	RETURNF GET_TRIBENAME(C_ID, GETNUM(TALENT, "추가종족")) == "봉래인"
CASE "반인간", "半人間"
	RETURNF TALENT:C_ID:인간 && (TALENT:C_ID:요괴 || TALENT:C_ID:요정 || TALENT:C_ID:신령 || TALENT:C_ID:유령 || TALENT:C_ID:츠쿠모가미 || TALENT:C_ID:인형)
CASE "약점잡음", "弱み握り"
;C_ID가 MASTER의 약점을 잡고 있다
	RETURNF CFLAG:C_ID:약점잡음
CASE "약점잡힘", "弱み握られ"
;C_ID가 MASTER에 약점을 잡히고 있다
	RETURNF CFLAG:C_ID:약점잡힘
CASE "반발각인", "反発刻印"
	RETURNF (MARK:C_ID:반발각인 >= 1)
CASE "시간각인", "時姦刻印"
	RETURNF (MARK:C_ID:시간각인 >= 1)
CASE "시간경험", "時姦経験"
	RETURNF (EXP:C_ID:시간경험 >= 1)
CASE "깨끗한교제", "清い交際"
	RETURNF (CFLAG:C_ID:깨끗한교제 >= 1)
CASE "구상실장상황", "口上実装状況"
	RETURNF (CFLAG:C_ID:구상실장상황 >= 1)
CASE "아이 딸린 사람", "子持ち"
	RETURNF (CFLAG:C_ID:아이인원수 >= 1)
CASE "동실", "同室"
	RETURNF (CFLAG:C_ID:현재위치 == CFLAG:MASTER:현재위치)
CASE "전라"
	{
	SIF EQUIP:C_ID:액세서리|| EQUIP:C_ID:모자
		 || EQUIP:C_ID:하반신속옷1 || EQUIP:C_ID:하반신속옷2
		 || EQUIP:C_ID:상반신속옷1 || EQUIP:C_ID:상반신속옷2
		 || EQUIP:C_ID:레오타드|| EQUIP:C_ID:보디슈트|| EQUIP:C_ID:원피스|| EQUIP:C_ID:기모노
		 || EQUIP:C_ID:바지|| EQUIP:C_ID:하반신윗도리 || EQUIP:C_ID:치마
		 || EQUIP:C_ID:상반신윗도리1 || EQUIP:C_ID:상반신윗도리2 || EQUIP:C_ID:외투
		 || EQUIP:C_ID:그외1 || EQUIP:C_ID:그외2 || EQUIP:C_ID:그외3 || EQUIP:C_ID:완부의복
	}
		RETURNF 0
	RETURNF 1
CASE "여자"
	RETURNF TALENT:C_ID:성별 == 1
CASE "임신"
	RETURNF TALENT:C_ID:임신
CASE "육아중"
	RETURNF TALENT:C_ID:육아중
CASE "후타나리"
	RETURNF TALENT:C_ID:성별 == 3
CASE "케모미미"
	RETURNF TALENT:C_ID:동물귀 != 0
CASE "인간귀"
	RETURNF TALENT:C_ID:동물귀 == 0
CASE "비처녀"
	SIF TALENT:C_ID:성별 == 2
		RETURNF 0
	RETURNF GROUPMATCH(TALENT:C_ID:처녀, 0, -1)
CASEELSE
	THROW 올바르지 않은 식별자입니다! TYPE - %TYPE%
ENDSELECT



;-------------------------------------------------
;캐릭터 비교 함수
;-------------------------------------------------
;전인수 필수
;스마트하다고는 먼 코피페고리 밀기이다
;-------------------------------------------------
@CHARA_COMPARE(VAR_NAME, VAR_ID, CHARA_A, TYPE, CHARA_B)
#FUNCTION
#DIMS VAR_NAME ;비교 대상 캐릭터 변수
#DIM  VAR_ID   ;비교 대상 캐릭터 변수의 ID
#DIM  CHARA_A  ;비교 대상 캐릭터 A의 등록 번호
#DIMS TYPE     ;비교 내용
#DIM  CHARA_B  ;비교 대상 캐릭터 B의 등록 번호
SELECTCASE VAR_NAME
CASE "ABL"
	SELECTCASE TYPE
	CASE "=="
		RETURNF ABL:CHARA_A:VAR_ID == ABL:CHARA_B:VAR_ID
	CASE ">"
		RETURNF ABL:CHARA_A:VAR_ID > ABL:CHARA_B:VAR_ID
	CASE ">="
		RETURNF ABL:CHARA_A:VAR_ID >= ABL:CHARA_B:VAR_ID
	CASE "<"
		RETURNF ABL:CHARA_A:VAR_ID < ABL:CHARA_B:VAR_ID
	CASE "<="
		RETURNF ABL:CHARA_A:VAR_ID <= ABL:CHARA_B:VAR_ID
	CASEELSE
		THROW 불명한 TYPE　%TYPE%
	ENDSELECT
	
CASE "BASE"
	SELECTCASE TYPE
	CASE "=="
		RETURNF BASE:CHARA_A:VAR_ID == BASE:CHARA_B:VAR_ID
	CASE ">"
		RETURNF BASE:CHARA_A:VAR_ID > BASE:CHARA_B:VAR_ID
	CASE ">="
		RETURNF BASE:CHARA_A:VAR_ID >= BASE:CHARA_B:VAR_ID
	CASE "<"
		RETURNF BASE:CHARA_A:VAR_ID < BASE:CHARA_B:VAR_ID
	CASE "<="
		RETURNF BASE:CHARA_A:VAR_ID <= BASE:CHARA_B:VAR_ID
	CASEELSE
		THROW 불명한 TYPE　%TYPE%
	ENDSELECT
	
CASE "MAXBASE"
	SELECTCASE TYPE
	CASE "=="
		RETURNF MAXBASE:CHARA_A:VAR_ID == MAXBASE:CHARA_B:VAR_ID
	CASE ">"
		RETURNF MAXBASE:CHARA_A:VAR_ID > MAXBASE:CHARA_B:VAR_ID
	CASE ">="
		RETURNF MAXBASE:CHARA_A:VAR_ID >= MAXBASE:CHARA_B:VAR_ID
	CASE "<"
		RETURNF MAXBASE:CHARA_A:VAR_ID < MAXBASE:CHARA_B:VAR_ID
	CASE "<="
		RETURNF MAXBASE:CHARA_A:VAR_ID <= MAXBASE:CHARA_B:VAR_ID
	CASEELSE
		THROW 불명한 TYPE　%TYPE%
	ENDSELECT
	
CASE "EXP"
	SELECTCASE TYPE
	CASE "=="
		RETURNF EXP:CHARA_A:VAR_ID == EXP:CHARA_B:VAR_ID
	CASE ">"
		RETURNF EXP:CHARA_A:VAR_ID > EXP:CHARA_B:VAR_ID
	CASE ">="
		RETURNF EXP:CHARA_A:VAR_ID >= EXP:CHARA_B:VAR_ID
	CASE "<"
		RETURNF EXP:CHARA_A:VAR_ID < EXP:CHARA_B:VAR_ID
	CASE "<="
		RETURNF EXP:CHARA_A:VAR_ID <= EXP:CHARA_B:VAR_ID
	CASEELSE
		THROW 불명한 TYPE　%TYPE%
	ENDSELECT
	
CASE "CFLAG"
	SELECTCASE TYPE
	CASE "=="
		RETURNF CFLAG:CHARA_A:VAR_ID == CFLAG:CHARA_B:VAR_ID
	CASE ">"
		RETURNF CFLAG:CHARA_A:VAR_ID > CFLAG:CHARA_B:VAR_ID
	CASE ">="
		RETURNF CFLAG:CHARA_A:VAR_ID >= CFLAG:CHARA_B:VAR_ID
	CASE "<"
		RETURNF CFLAG:CHARA_A:VAR_ID < CFLAG:CHARA_B:VAR_ID
	CASE "<="
		RETURNF CFLAG:CHARA_A:VAR_ID <= CFLAG:CHARA_B:VAR_ID
	CASEELSE
		THROW 불명한 TYPE　%TYPE%
	ENDSELECT
	
CASE "PALAM"
	SELECTCASE TYPE
	CASE "=="
		RETURNF PALAM:CHARA_A:VAR_ID == PALAM:CHARA_B:VAR_ID
	CASE ">"
		RETURNF PALAM:CHARA_A:VAR_ID > PALAM:CHARA_B:VAR_ID
	CASE ">="
		RETURNF PALAM:CHARA_A:VAR_ID >= PALAM:CHARA_B:VAR_ID
	CASE "<"
		RETURNF PALAM:CHARA_A:VAR_ID < PALAM:CHARA_B:VAR_ID
	CASE "<="
		RETURNF PALAM:CHARA_A:VAR_ID <= PALAM:CHARA_B:VAR_ID
	CASEELSE
		THROW 불명한 TYPE　%TYPE%
	ENDSELECT
	
CASE "TALENT"
	SELECTCASE TYPE
	CASE "=="
		RETURNF TALENT:CHARA_A:VAR_ID == TALENT:CHARA_B:VAR_ID
	CASE ">"
		RETURNF TALENT:CHARA_A:VAR_ID > TALENT:CHARA_B:VAR_ID
	CASE ">="
		RETURNF TALENT:CHARA_A:VAR_ID >= TALENT:CHARA_B:VAR_ID
	CASE "<"
		RETURNF TALENT:CHARA_A:VAR_ID < TALENT:CHARA_B:VAR_ID
	CASE "<="
		RETURNF TALENT:CHARA_A:VAR_ID <= TALENT:CHARA_B:VAR_ID
	CASEELSE
		THROW 불명한 TYPE　%TYPE%
	ENDSELECT
	
CASE "TCVAR"
	SELECTCASE TYPE
	CASE "=="
		RETURNF TCVAR:CHARA_A:VAR_ID == TCVAR:CHARA_B:VAR_ID
	CASE ">"
		RETURNF TCVAR:CHARA_A:VAR_ID > TCVAR:CHARA_B:VAR_ID
	CASE ">="
		RETURNF TCVAR:CHARA_A:VAR_ID >= TCVAR:CHARA_B:VAR_ID
	CASE "<"
		RETURNF TCVAR:CHARA_A:VAR_ID < TCVAR:CHARA_B:VAR_ID
	CASE "<="
		RETURNF TCVAR:CHARA_A:VAR_ID <= TCVAR:CHARA_B:VAR_ID
	CASEELSE
		THROW 불명한 TYPE　%TYPE%
	ENDSELECT
	
CASE "MARK"
	SELECTCASE TYPE
	CASE "=="
		RETURNF MARK:CHARA_A:VAR_ID == MARK:CHARA_B:VAR_ID
	CASE ">"
		RETURNF MARK:CHARA_A:VAR_ID > MARK:CHARA_B:VAR_ID
	CASE ">="
		RETURNF MARK:CHARA_A:VAR_ID >= MARK:CHARA_B:VAR_ID
	CASE "<"
		RETURNF MARK:CHARA_A:VAR_ID < MARK:CHARA_B:VAR_ID
	CASE "<="
		RETURNF MARK:CHARA_A:VAR_ID <= MARK:CHARA_B:VAR_ID
	CASEELSE
		THROW 불명한 TYPE　%TYPE%
	ENDSELECT
	
CASEELSE
	THROW 불명한 VAR_NAME　%VAR_NAME%
ENDSELECT

[SKIPSTART]
이것을 코피페 해 치환하면 항목을 늘릴 수 있다
CASE "CVAR"
	SELECTCASE TYPE
	CASE "=="
		RETURNF CVAR:CHARA_A:VAR_ID == CVAR:CHARA_B:VAR_ID
	CASE ">"
		RETURNF CVAR:CHARA_A:VAR_ID > CVAR:CHARA_B:VAR_ID
	CASE ">="
		RETURNF CVAR:CHARA_A:VAR_ID >= CVAR:CHARA_B:VAR_ID
	CASE "<"
		RETURNF CVAR:CHARA_A:VAR_ID < CVAR:CHARA_B:VAR_ID
	CASE "<="
		RETURNF CVAR:CHARA_A:VAR_ID <= CVAR:CHARA_B:VAR_ID
	CASEELSE
		THROW 불명한 TYPE　%TYPE%
	ENDSELECT
[SKIPEND]



;-------------------------------------------------
;신분 평가 표시 함수
;-------------------------------------------------
;원래는@PRINT_알파벳평가
;인수를 평가 대상 수치로 하는 것으로 범용화해
;RANK_SCALE의 명칭을 알기 쉽게 했다
;-------------------------------------------------
@PRINT_RANK(VAR_VALUE, RANK_SCALE)
#DIM  VAR_VALUE  ;평가 대상 수치
#DIMS RANK_SCALE ;평가에 사용하는 척도의 종류
#DIM  RANK       ;평가 랭크, 수가 작을 정도 우수
#DIM  RANK_NUM   ;평가 척도에 포함되는 평가의 종수
CALL CALC_RANK(VAR_VALUE, RANK_SCALE, RANK, RANK_NUM)
CALL PRINT_ALPHABET(RANK, RANK_NUM)



;-------------------------------------------------
;신분 평가 산출 함수
;-------------------------------------------------
;RANK_SCALE에 의거해 VAR_VALUE의 평가를 실시한다
;REF에 의해 RANK/RANK_NUM로서 건네받은 인수의 수치를 직접 고쳐 쓴다
;KR판 최대랭크 각 1단계씩 더 있음
;-------------------------------------------------
@CALC_RANK(VAR_VALUE, RANK_SCALE, RANK, RANK_NUM)
#DIM      VAR_VALUE  ;평가 대상 수치
#DIMS     RANK_SCALE ;평가에 사용하는 척도의 종류
#DIM  REF RANK       ;평가 랭크, 수가 작을 정도 우수
#DIM  REF RANK_NUM   ;평가 척도에 포함되는 평가의 종수
SELECTCASE RANK_SCALE
CASE "MAX_50000"
;호감도용
	RANK_NUM = 11
	SELECTCASE VAR_VALUE
	CASE IS >= 100000
		RANK = 0
	CASE IS >= 50000
		RANK = 1
	CASE IS >= 30000
		RANK = 2
	CASE IS >= 10000
		RANK = 3
	CASE IS >=  5000
		RANK = 4
	CASE IS >=  3000
		RANK = 5
	CASE IS >=  1500
		RANK = 6
	CASE IS >=  1000
		RANK = 7
	CASE IS >=   500
		RANK = 8
	CASE IS >=   100
		RANK = 9
	CASEELSE
		RANK = 10
	ENDSELECT
CASE "MAX_20000"
;신뢰도용
	RANK_NUM = 11
	SELECTCASE VAR_VALUE
	CASE IS >= 40000
		RANK = 0
	CASE IS >= 20000
		RANK = 1
	CASE IS >= 10000
		RANK = 2
	CASE IS >=  3000
		RANK = 3
	CASE IS >=  1000
		RANK = 4
	CASE IS >=   500
		RANK = 5
	CASE IS >=   150
		RANK = 6
	CASE IS >=   100
		RANK = 7
	CASE IS >=    50
		RANK = 8
	CASE IS >=    10
		RANK = 9
	CASEELSE
		RANK = 10
	ENDSELECT
CASE "MAX_99"
;기술계 이외의ABL
	;숫자가 세로에 줄서면(자) 매우 보기 나뻐서 의도적으로 인덴트않고들 하고 있습니다
	RANK_NUM = 11
	SELECTCASE VAR_VALUE
	CASE IS >= 99
			RANK = 0
	CASE IS >= 80
			RANK = 1
	CASE IS >= 60
			RANK = 2
	CASE IS >= 40
			RANK = 3
	CASE IS >= 20
			RANK = 4
	CASE IS >= 10
			RANK = 5
	CASE IS >=  5
			RANK = 6
	CASE IS >=  3
			RANK = 7
	CASE IS >=  2
			RANK = 8
	CASE IS >=  1
			RANK = 9
	CASEELSE
			RANK = 10
	ENDSELECT
CASE "MAX_6"
;기능계 ABL
	RANK_NUM = 8
	SELECTCASE VAR_VALUE
	CASE IS >= 7
			RANK = 0
	CASE IS >= 6
			RANK = 1
	CASE IS >= 5
			RANK = 2
	CASE IS >= 4
			RANK = 3
	CASE IS >= 3
			RANK = 4
	CASE IS >= 2
			RANK = 5
	CASE IS >= 1
			RANK = 6
	CASEELSE
			RANK = 7
	ENDSELECT
CASE "MAX_20"
	;텍붕이 전투능력
	RANK_NUM = 21
	SELECTCASE VAR_VALUE
	CASE IS >= 20
			RANK = 0
	CASE IS >= 19
			RANK = 1
	CASE IS >= 18
			RANK = 2
	CASE IS >= 17
			RANK = 3
	CASE IS >= 16
			RANK = 4
	CASE IS >= 15
			RANK = 5
	CASE IS >= 14
			RANK = 6
	CASE IS >= 13
			RANK = 7
	CASE IS >= 12
			RANK = 8
	CASE IS >= 11
			RANK = 9
	CASE IS >=  10
			RANK = 10
	CASE IS >=  9
			RANK = 11
	CASE IS >=  8
			RANK = 12
	CASE IS >=  7
			RANK = 13
	CASE IS >=  6
			RANK = 14
	CASE IS >=  5
			RANK = 15
	CASE IS >=  4
			RANK = 16
	CASE IS >=  3
			RANK = 17
	CASE IS >=  2
			RANK = 18
	CASE IS >=  1
			RANK = 19
	CASEELSE
			RANK = 20
	ENDSELECT
CASEELSE
	THROW 불명한 RANK_SCALE %RANK_SCALE%
ENDSELECT



;-------------------------------------------------
;랭크 평가 표시 함수
;-------------------------------------------------
;랭크 평가(숫자가 작을 정도 우수)의 내용을 알파벳 표기해 컬러 표시한다
;형식마저 있으면 별로 PRINT_RANK가 아니어도 사용할 수 있어
;ARG=1로 전각 ; 한판 임의수정, Ph 추가에 따른 조정. 이후 함수 사용(벌레배틀)에 따라 원판대로 사용할지 결정할 예정
;-------------------------------------------------
@PRINT_ALPHABET(RANK, RANK_NUM, ARG)
#DIM RANK
#DIM RANK_NUM
#DIMS CONST STR_RANK11, 11 = "Ph","Ex", "SS", " S", " A", " B", " C", " D", " E", " F", " G"
#DIMS CONST STR_RANK21, 21 = "Ph","EX", "SS+", "SS", "SS-", "S+", "S", "S-", "A", "A-", "B+", "B", "C+", "C", "C-", "D+", "D", "D-", "E", "F", "F-"
#DIMS CONST STR_RANK8,   8 = "Ph","Ex", " S", " A", " B", " C", " D", " E"
#DIMS CONST STR_RANK11_F, 11 = "ＰＨ", "ＳＳＳ", "ＳＳ", "Ｓ", "Ａ", "Ｂ", "Ｃ", "Ｄ", "Ｅ", "Ｆ", "Ｇ"
#DIMS CONST STR_RANK8_F,   8 = "ＰＨ", "ＥＸ", "Ｓ", "Ａ", "Ｂ", "Ｃ", "Ｄ", "Ｅ"
{
#DIMS  CONST C_RANK21, 21 = 
	"Ph","SSS", "SS+", "SS", "SS-", "S+", "S", "S-", "A", "A-", "B+", "B", "C+", "C", "C-", "D+", "D", "D-", "E", "F", "F-"
}
{
#DIMS  CONST C_RANK11, 11 = 
	"C_P_PURPLE", "C_BLUE","C_WHITE", "C_WHITE", "C_PINK", "C_RED", 
	"C_ORANGE", "C_YELLOW", "C_GREEN", "C_AQUA", "C_GRAY"
}
#DIMS  CONST C_RANK8,   8 = "C_P_PURPLE", "C_BLUE","C_WHITE", "C_PINK", "C_RED", "C_ORANGE", "C_YELLOW", "C_GRAY"

IF ARG
	SELECTCASE RANK_NUM
	CASE 10
		CALL COLOR_PRINT(STR_RANK11_F:RANK, C_RANK11:RANK, 2)
	CASE  7
		CALL COLOR_PRINT(STR_RANK8_F:RANK, C_RANK8:RANK, 2)
	CASEELSE
		THROW 부정한 RANK_NUM {RANK_NUM}
	ENDSELECT
ELSE
	SELECTCASE RANK_NUM
	CASE 21
		CALL COLOR_PRINT(STR_RANK21:RANK, C_RANK21:RANK, 2)
	CASE 11
		CALL COLOR_PRINT(STR_RANK11:RANK, C_RANK11:RANK, 2)
	CASE  8
		CALL COLOR_PRINT(STR_RANK8:RANK, C_RANK8:RANK, 2)
	CASEELSE
		THROW 부정한 RANK_NUM {RANK_NUM}
	ENDSELECT
ENDIF
RESETCOLOR



;-------------------------------------------------
;물이 들어 PRINT 함수
;-------------------------------------------------
;건네준 문자를 건네준 색으로 PRINT 해 RESETCOLOR
;광역 변수로 DIM는 있는 색의 이름만 가능(추가는 용이)
;-------------------------------------------------
@COLOR_PRINT(ARGS, C_NAME, STR_NUM = 2)
#DIMS C_NAME
#DIM  STR_NUM
SIF !STRLENS(ARGS)
	RETURN
SELECTCASE C_NAME
CASE "C_P_PURPLE"
	SETCOLOR C_P_PURPLE
CASE "C_BLUE" ;KR판 오리지날
	SETCOLOR C_BLUE
CASE "C_WHITE"
	SETCOLOR C_WHITE
CASE "C_PINK"
	SETCOLOR C_PINK
CASE "C_RED"
	SETCOLOR C_RED
CASE "C_ORANGE"
	SETCOLOR C_ORANGE
CASE "C_YELLOW"
	SETCOLOR C_YELLOW
CASE "C_GREEN"
	SETCOLOR C_GREEN
CASE "C_AQUA"
	SETCOLOR C_AQUA
CASE "C_GRAY"
	SETCOLOR C_GRAY
CASE "Ph"
    SETCOLOR 0xFF1111
CASE "SSS"
    SETCOLOR 0xFA58F4
CASE "SS+"
    SETCOLOR 0xFA58F4
CASE "SS"
    SETCOLOR 0xFA58F4
CASE "SS-"
    SETCOLOR 0xFA58F4
CASE "S+"
    SETCOLOR 0xFA58F4
CASE "S"
    SETCOLOR 0xFF00FF
CASE "S-"
    SETCOLOR 0x8A0886
CASE "A"
    SETCOLOR 0x0000FF
CASE "A-"
    SETCOLOR 0x08088A
CASE "B+"
    SETCOLOR 0xFA5858
CASE "B"
    SETCOLOR 0xFF0000
CASE "C+"
    SETCOLOR 0xF3F781
CASE "C"
    SETCOLOR 0xFFFF00
CASE "C-"
    SETCOLOR 0xAEB404
CASE "D+"
    SETCOLOR 0x81DAF5
CASE "D"
    SETCOLOR 0x00BFFF
CASE "D-"
    SETCOLOR 0x086A87
CASE "E"
    SETCOLOR 0x00FF40
CASE "F"
    SETCOLOR 0x848484
CASE "F-"
    SETCOLOR 0x2E2E2E
CASEELSE
	THROW 부정한 C_NAME %C_NAME%
ENDSELECT
PRINTFORM %ARGS, STR_NUM%
RESETCOLOR



;-------------------------------------------------
;BASE 컬러 바 함수
;-------------------------------------------------
;체력등의 컬러 바
;-------------------------------------------------
@BASE_BAR(C_ID, BASE_NAME, BAR_LENGTH, COLOR_NAME, OP)
#DIM  C_ID
#DIMS BASE_NAME
#DIM  BAR_LENGTH
#DIMS COLOR_NAME
#DIMS OP
#DIM  BASE_ID
BASE_ID = FINDELEMENT(BASENAME, BASE_NAME)
SIF BASE_ID < 0
	THROW 존재하지 않는 BASE_NAME %BASE_NAME%
SIF !STRCOUNT(OP, "「종류 표기 없음」")
	PRINTFORM %BASE_NAME, 4% 
CALL PRINT_COLORBAR(BASE:C_ID:BASE_ID, MAXBASE:C_ID:BASE_ID, BAR_LENGTH, UNICODE(0x2585), UNICODE(0x2585), BARCOLORSET(COLOR_NAME), RESULT:1)
IF !STRCOUNT(OP, "「숫자 표기 없음」")
	IF BUFF:C_ID:BASE_ID > 0
		SETCOLOR C_AQUA
	ELSEIF BUFF:C_ID:BASE_ID < 0
		SETCOLOR C_YELLOW
	ENDIF
	PRINTFORM  ({BASE:C_ID:BASE_ID, 5}/{MAXBASE:C_ID:BASE_ID, 5}) 
	RESETCOLOR
ENDIF
SIF STRCOUNT(OP, "「개행」")
	PRINTFORML 

;-------------------------------------------------
;INFO用の改良型BASEカラーバー関数
;-------------------------------------------------
@BASE_BAR_2(C_ID, BASE_NAME, BASE_NAME_SHORT, BAR_LENGTH, COLOR_NAME)
#DIM  C_ID
#DIMS BASE_NAME
#DIMS BASE_NAME_SHORT
#DIM  BAR_LENGTH
#DIMS COLOR_NAME
#DIM  BASE_ID
BASE_ID = FINDELEMENT(BASENAME, BASE_NAME)
SIF BASE_ID < 0
	THROW 존재하지 않는BASE_NAME %BASE_NAME%
IF BASE_NAME == "정력" && TALENT:C_ID:농후정액
	FONTBOLD
	SETCOLOR C_CREAM
	PRINTFORM %BASE_NAME_SHORT% 
	FONTREGULAR
	RESETCOLOR
ELSE
	PRINTFORM %BASE_NAME_SHORT% 
ENDIF
CALL PRINT_COLORBAR(BASE:C_ID:BASE_ID, MAXBASE:C_ID:BASE_ID, BAR_LENGTH, UNICODE(0x2585), UNICODE(0x2585), BARCOLORSET(COLOR_NAME), RESULT:1)
IF BUFF:C_ID:BASE_ID > 0
	SETCOLOR C_AQUA
ELSEIF BUFF:C_ID:BASE_ID < 0
	SETCOLOR C_YELLOW
ENDIF
PRINTFORM ({BASE:C_ID:BASE_ID, 5}) 
RESETCOLOR

;-------------------------------------------------
;컬러 스탬프 함수
;-------------------------------------------------
;특정의 기호를 특정의 색으로 나란해질 수 있다
;MARK의 표시용이지만무슨 그 외에도 사용할 수 있겠지요
;ARG=1이면 왼쪽 맞춤
;-------------------------------------------------
@COLOR_STAMP(STAMP_NUM, MAX_NUM, STAMP_STR, STAMP_COLOR, ARG)
#DIM  STAMP_NUM   ;늘어놓는 스탬프의 수
#DIM  MAX_NUM     ;스탬프의 최대수
#DIMS STAMP_STR   ;스탬프에 사용하는 캐릭터라인
#DIM  STAMP_COLOR ;스탬프의 색
#DIM  STAMP_LENGTH;스탬프 캐릭터라인의 길이
STAMP_LENGTH = STRLENS(STAMP_STR)
SIF !STAMP_LENGTH
	THROW STAMP_STR가 지정되고 있지 않습니다
SIF STAMP_COLOR
	SETCOLOR STAMP_COLOR
SIF !ARG
	PRINTFORM %" " * (MAX_NUM - STAMP_NUM) * STAMP_LENGTH%
PRINTFORM %STAMP_STR * STAMP_NUM%
RESETCOLOR

;-------------------------------------------------
;캐릭터 추첨 함수
;-------------------------------------------------
;캐릭터리스트로부터 랜덤으로 1명을 선출한다
;반환값은 등록 번호, 실패하면(자)―1
;-------------------------------------------------
@RAND_CHARASELECT(L_TYPE = "주인공 이외의캐릭터리스트")
#DIMS L_TYPE                       ;추첨 대상 타입
#DIM  L_ID                         ;리스트의 클래스 ID
#DIM  CHARA_LIST, 캐릭터수상한 ;작성하는 리스트
#DIM  CHARA_CNT                    ;캐릭터 카운터
CALL MAKE_CHARA_LIST("주인공 이외의캐릭터리스트", L_ID, CHARA_LIST, CHARA_CNT)
SIF !CHARA_CNT
	RETURN -1
RETURN CHARA_LIST:(RAND:CHARA_CNT)



;----------------------------------------------------------------------------------------------------
;캐릭터의 등장 판정
;우선 당신은 튕기듯이 했다
;----------------------------------------------------------------------------------------------------
@CAN_MEET(CHARA)
#FUNCTION
#DIM CHARA
SIF !CHARA
	RETURNF 0
SIF !EXISTCSV(CHARA)
	RETURNF 0
SIF CHARA >= CHARANUM
	RETURNF 0
SIF CFLAG:CHARA:출금||TALENT:CHARA:사망
	RETURNF 0
SIF TALENT:CHARA:창녀
	RETURNF 0
SIF TALENT:CHARA:렌탈창녀
	RETURNF 0
SIF CHARA == FLAG:역극
	RETURNF 0
RETURNF 1

;----------------------------------------------------------------------------------------------------
;현재지점으로부터 이동 가능한 장소에 이동
;방으로부터 내쫓아질 때 등
;----------------------------------------------------------------------------------------------------
@GETOUT(ARG)
TCVAR:ARG:쫒겨난시각 = TIME
TCVAR:ARG:쫒겨난장소 = CFLAG:ARG:현재위치
FOR LOCAL, MINROOM(), MAXROOM
	;세련되지 않지만、번호 관계상幽香私室에서는 발코니로 쫓겨나기에 개별처리
	IF CFLAG:ARG:현재위치 == P463몽환관유카방
		CFLAG:ARG:현재위치 = P465몽환관홀
		BREAK
	ENDIF
	IF CAN_MOVE(CFLAG:ARG:현재위치, LOCAL) & 1
		CFLAG:ARG:현재위치 = LOCAL
		BREAK
	ENDIF
NEXT


;----------------------------------------------------------------------------------------------------
;캐릭터의 랜덤 선발 함수
;부실 처리로 가능한 한 간소한 추첨 함수를 이라고 생각했다(RAND_CHARASELECT는 너무 좀 열중하고)
;건네준 캐릭터는 선택되지 않는다
;출금캐릭터가 너무 많으면(자) 무한루프의 우려가 있는 것이 난점
;난점이라고는 말하지만 전캐릭터 대상의 추첨에서는
;극단적인 프레잉을 하지 않으면 문제는 되지 않는, 은 두
;----------------------------------------------------------------------------------------------------
@RAND_PERSON(CHARA)
#FUNCTION
#DIM CHARA
#DIM HIT_CHARA
DO
	HIT_CHARA = RAND(1, 캐릭터수상한)
	SIF !CAN_MEET(HIT_CHARA) || HIT_CHARA == CHARA
		CONTINUE
	BREAK
LOOP 1
RETURNF HIT_CHARA



;----------------------------------------------------------------------------------------------------
;자택위치 취득 함수
;----------------------------------------------------------------------------------------------------
@GET_CHARAHOME(CHARA)
#FUNCTION
#DIM CHARA
;MASTER는 초기위치 정해져 있다
SIF CHARA == MASTER
	RETURNF CFLAG:CHARA:초기위치
;거주하는 플래그 서고 있다면 정해져 있다
SIF CHARA == FLAG:더부살이캐릭터
	RETURNF CFLAG:CHARA:초기위치
;주소 부정의 캐릭터는 먼저
SIF GROUPMATCH(CSVCFLAG(CHARA, GETNUM(CFLAG, "초기위치")), 0, 99)
	RETURNF -100
RETURNF CSVCFLAG(CHARA, GETNUM(CFLAG, "초기위치"))


;----------------------------------------------------------------------------------------------------
;장소 나토리 이득 함수
;MAIN_MAP 나름으로 거동이 바뀌어 버려 개인적으로 기분 나쁘다
;문제점：GET_MAP_REPLACEMENT를 사용이 끝난 PLACE_ID를 받으면(자) 오동작≒산책 맵의 장소 ID는 받아들이지 않습니다
;----------------------------------------------------------------------------------------------------
@GET_PLACENAME(PLACE_ID)
#FUNCTIONS
#DIM PLACE_ID
SIF PLACE_ID == SUKIMA()
	RETURNF "스키마 공간"
SIF PLACE_ID == OMANEKIBEYA()
	RETURNF OMANEKI_PLACE()
IF GET_MAPID(PLACE_ID) == MAIN_MAP
	RETURNF NAME_FROM_PLACE(PLACE_ID)
ELSE
	RETURNF STR:(6000 + GET_MAP_REPLACEMENT(PLACE_ID) / 10)
ENDIF

;----------------------------------------------------------------------------------------------------
;배열 추첨 F함수
;----------------------------------------------------------------------------------------------------
@ARRAY_HIT(HIT_LIST, LIST_SIZE)
#FUNCTION
#DIM REF HIT_LIST ;확률 분포 리스트
#DIM     LIST_SIZE;확률 분포 리스트의 사이즈
#DIM     CHK_ID   ;판정 대상이 되는 요소
#DIM     HIT_RAND ;추첨 난수 처리
LOCAL = MAX(SUMARRAY(HIT_LIST, 0, LIST_SIZE), 1)
HIT_RAND = RAND(0, LOCAL)
;DEBUGPRINTFORML LIST_SIZE={LIST_SIZE}　HIT_RAND{HIT_RAND}
FOR CHK_ID, 0, LIST_SIZE
	SIF HIT_RAND < SUMARRAY(HIT_LIST, 0, CHK_ID + 1)
		RETURNF CHK_ID
NEXT
;THROW 추첨 실패
;카운터 추첨 실패에 의한 THROW 빠짐이 발생하고 있기 때문에-1을 돌려주기로 한다
RETURNF -1

;----------------------------------------------------------------------------------------------------
;배열 RAND화 함수
;중복 제한 없음이므로 적당 FISHER_YATES_SHAFFLE와 구분하여 사용해 주세요
;----------------------------------------------------------------------------------------------------
@ARRAY_RAND(RAND_ARRAY, ARRAY_SIZE, RAND_MIN, RAND_MAX)
#DIM REF RAND_ARRAY; 대상 배열
#DIM     ARRAY_SIZE; 배열 사이즈(1이상)
#DIM     RAND_MIN  ; RAND의 하한(0이상)
#DIM     RAND_MAX  ; RAND의 상한-1, 이 수자체는 추첨으로 선택되지 않는다(RAND_MIN+1이상)
#DIM     ID_ARRAY  ; 루프용
FOR ID_ARRAY, 0, ARRAY_SIZE
	RAND_ARRAY:ID_ARRAY = RAND(RAND_MIN, RAND_MAX)
NEXT


;----------------------------------------------------------------------------------------------------
;FISHER_YATES_SHAFFLE(F함수판)
;소스는 wikipedia
;CALLF FUNC_FISHER_YATES_SHAFFLE(LOCAL, 10)
;이것으로 LOCAL:0~9에 0~9가 중복없이 대입된다
;----------------------------------------------------------------------------------------------------
@FUNC_FISHER_YATES_SHAFFLE(ARRAY, ARRAY_SIZE)
#FUNCTION
#DIM REF ARRAY   ;대상 배열
#DIM ARRAY_SIZE  ;배열의 길이(2이상의 수치로 해 주세요)
#DIM ELE_SHAFFLE ;셔플 대상 요소
VARSET ARRAY, -1
ARRAY:0 = 0
;요소 0에 대한↓의 처리는 반드시 0이 되기 때문에  1이후에 k
FOR LOCAL:0, 1, ARRAY_SIZE
	ELE_SHAFFLE = RAND(0, LOCAL:0 + 1)
	;거동 변함없을 것 같다면 if 마련하는 것보다 소안내가 처리 얼마 안되게 되거나 전과?
	;SIF ELE_SHAFFLE != LOCAL:0
	ARRAY:(LOCAL:0) = ARRAY:ELE_SHAFFLE
	ARRAY:ELE_SHAFFLE = LOCAL:0
NEXT


;----------------------------------------------------------------------------------------------------
;복수행 자동 표시 함수
;일종의 초간이 애니메이션
;1초에 1행 덧붙여 씀 해 나가 함수야
;건네받은 배열의 요소를 차례로 표시한다
;본격적으로 움직여 도미인 에 째-실마리응 사용해라
;사용 개소는 나즈린의 다우징코만드
;----------------------------------------------------------------------------------------------------
@PRINT_GROUP(COMMENT, NUM_COMMENT, TIME_REDRAW = 1000)
#DIMS REF COMMENT         ;표시하는 캐릭터라인의 배열
#DIM  NUM_COMMENT         ;배열의 요소수
#DIM  PREV_REDRAW         ;일시 퇴피용
#DIM  TIME_REDRAW         ;행 추가의 간격, 표준으로 1초
#DIM  DYNAMIC NOW_COMMENT ;표시 은폐 제어용
PREV_REDRAW = CURRENTREDRAW()
REDRAW 0
FOR LOCAL:0, 0, NUM_COMMENT
	FOR LOCAL:1, 0, NUM_COMMENT
		IF LOCAL:1 <= NOW_COMMENT
			PRINTFORML %COMMENT:(LOCAL:1)%
		ELSE
			PRINTFORML 
		ENDIF
	NEXT
	TWAIT TIME_REDRAW, 0
	NOW_COMMENT ++ 
	SIF LOCAL:0 < NUM_COMMENT -1
		CLEARLINE NUM_COMMENT
NEXT
REDRAW PREV_REDRAW
WAIT


;----------------------------------------------------------------------------------------------------
;ARG(DAY)를 연월일로 변환하는 함수
;----------------------------------------------------------------------------------------------------
@DAY_TO_DATE(ARG)
#FUNCTION
VARSET LOCAL
;겨울의 월 31일은 예외
SIF ARG % 124 == 0
	LOCAL:5 = 1
;연눈
LOCAL:1 = ARG / 124
SIF !LOCAL:5
	LOCAL:1 += 1
;월
IF LOCAL:5
	LOCAL:2 = 4
ELSEIF ARG % 124 % 31 == 0
	LOCAL:2 = ARG % 124 / 31
ELSE
	LOCAL:2 = ARG % 124 / 31 + 1
ENDIF
;일
IF LOCAL:5 || ARG % 124 % 31 == 0
	LOCAL:3 = 31
ELSE
	LOCAL:3 = ARG % 124 % 31
ENDIF
LOCAL = LOCAL:1 * 1000 + LOCAL:2 * 100 + LOCAL:3
RETURNF LOCAL

;----------------------------------------------------------------------------------------------------
;ARG(연월일)를 DAY로 변환하는 함수
;----------------------------------------------------------------------------------------------------
@DATE_TO_DAY(ARG)
#FUNCTION
VARSET LOCAL
LOCAL += (ARG / 1000 - 1) * 124
LOCAL += (ARG % 1000 / 100 - 1) * 31
LOCAL += ARG % 1000 % 100
RETURNF LOCAL

;----------------------------------------------------------------------------------------------------
;ARG(DAY)를 연월일(요일)에 표시하는 함수
;ARG가 연월일이다면 ARG:1을 실로 하는 것
;----------------------------------------------------------------------------------------------------
@PRINT_DATE(ARG, ARG:1)
;ARG를 DAY와 판정
IF !ARG:1
	LOCAL:1 = DAY_TO_DATE(ARG)
	LOCAL:2 = ARG
;ARG를 연월일과 판정
ELSE
	LOCAL:1 = ARG
	LOCAL:2 = DATE_TO_DAY(ARG)
ENDIF
LOCAL:3 = LOCAL:1 % 1000 / 100
PRINTFORM {LOCAL:1 / 1000}년째 %GET_MONTH(LOCAL:3)% {LOCAL:1 % 1000 % 100}일(%GET_DAY(LOCAL:2)%)

@PRINT_DATE_F(ARG)
#FUNCTIONS
LOCAL = DAY_TO_DATE(ARG)
LOCAL:1 = LOCAL / 1000
LOCAL:2 = LOCAL % 1000 / 100
LOCAL:3 = LOCAL % 1000 % 100
LOCALS = {LOCAL:1}년째 %GET_MONTH(LOCAL:2)%의 {LOCAL:3}일
RETURNF LOCALS

;----------------------------------------------------------------------------------------------------
;복수 캐릭터라인 카운트 F함수
;----------------------------------------------------------------------------------------------------
;TARGET_STR에 포함되는 복수의 캐릭터라인의 수를 검색한다
;TARGET_STR, KEY_STR 모두"/"를 칸막이로서 복수의 단어를 카운트 한다
;TARGET_STR, KEY_STR로 한 번에 건네주는 단어의 종류는 각각 100 종류 미만, 어군은 1000개 미만으로 하는 것
;
;동작예)
;TARGET_STR："토끼/토끼/토끼/여우/고양이/고양이/"
;예 1)
;　KEY_STR："토끼/고양이/"
;　"토끼"가 3,"고양이"가 2로 합계치의 5를 돌려준다
;예 2)
;　KEY_STR："여우/고양이/"
;　"여우"가 1,"고양이"가 2로 합계치의 3을 돌려준다
;예 3)
;　KEY_STR："토끼/토끼/"
;　"토끼"가 3, 의 처리를 2회분 해 6을 돌려준다
;----------------------------------------------------------------------------------------------------
@STR_MULTI_COUNT(TARGET_STR, KEY_STR)
#FUNCTION
#DIMS TARGET_STR             ;검색 대상캐릭터라인
#DIMS KEY_STR                ;검색하고 싶은 어군, 어군의 종류의 상한은 100 종류
#DIMS DYNAMIC KEY_LIST, 100  ;분할 후의 단어 리스트
#DIM  DYNAMIC KEY_CNT,  100  ;각 단어의 출현 회수
#DIM  DYNAMIC KEY_NUM        ;단어의 총수
#DIM          KEY_ID         ;루프 처리용
#DIM  DYNAMIC STR_CNT        ;카운트 개수
#DIMS DYNAMIC TEMP_STR, 1000 ;SPLIT용 일차 배열
#DIM  DYNAMIC TEMP_NUM       ;일차 배열로 사용한 요소수
#DIM          TEMP_RESULT    ;RESULT 퇴피
;만약을 위해
TARGET_STR '= REPLACE(TARGET_STR, "\/+", "/")
CALLF CNT_SPLIT(KEY_STR, KEY_LIST, KEY_CNT, KEY_NUM)

TEMP_RESULT = RESULT
SPLIT TARGET_STR, "/", TEMP_STR
TEMP_NUM = RESULT
FOR KEY_ID, 0, KEY_NUM
	STR_CNT += MATCH(TEMP_STR, KEY_LIST:KEY_ID, 0, TEMP_NUM) * KEY_CNT:KEY_ID
NEXT
RESULT = TEMP_RESULT
RETURNF STR_CNT


;----------------------------------------------------------------------------------------------------
;카운트 기능 붙어 있는 SPLIT 함수
;----------------------------------------------------------------------------------------------------
;·RESULT를 오염하지 않고, F함수 그 중에서 사용 가능
;·CALLF로 사용, REF를 사용해 변수를 직접 고쳐 쓴다
;·인수 필수, 단어 리스트/출현 개수 리스트의 배열 상한으로 주의!
;·단락 문자는"/"으로 고정
;·STR용의 배열 변수와 별로, 각 단어의 출현 회수 리스트를 추가
;·반환값 1) STR_LIST,"/"그리고 분할되고 출력되는 단어 리스트
;·반환값 2) CNT_LIST, 각 단어의 출현 회수 리스트
;·반환값 3) STR_NUM, 단어의 종류의 총수
;·TARGET_STR로 한 번에 건네주는 단어의 종류는 100 종류 미만, 어군은 1000개 미만으로 하는 것
;동작예)
;TARGET_STR："레이무/레이무/레이무/레이무/마리사/마리사/사나에/"
;　STR_LIST:0 == "레이무"
;　STR_LIST:1 == "마리사"
;　STR_LIST:2 == "사나에"
;　CNT_LIST:0 == 4   ;"레이무"의 출현 회수는 4회
;　CNT_LIST:1 == 2   ;"마리사"의 출현 회수는 2회
;　CNT_LIST:2 == 1   ;"사나에"의 출현 회수는 1회
;　STR_NUM    == 3   ;"레이무","마리사","사나에"로 합계 3 종류
;----------------------------------------------------------------------------------------------------
@CNT_SPLIT(TARGET_STR, STR_LIST, CNT_LIST, STR_NUM)
#FUNCTION
#DIMS         TARGET_STR     ;분할 대상 STR
#DIMS         NEW_STR        ;갱신용 일시 STR
#DIMS REF     STR_LIST       ;단어 리스트
#DIM  REF     CNT_LIST       ;각 단어의 출현 개수 리스트
#DIM  REF     STR_NUM        ;단어의 종류의 총수
#DIMS DYNAMIC TEMP_STR, 1000 ;SPLIT용 일차 배열
#DIM  DYNAMIC TEMP_NUM       ;일차 배열로 사용한 요소수
#DIM          TEMP_RESULT    ;RESULT 퇴피
#DIM          TEMP_ID        ;루프용
VARSET STR_LIST
VARSET CNT_LIST
STR_NUM = 0

TEMP_RESULT = RESULT
SPLIT TARGET_STR, "/", TEMP_STR
TEMP_NUM = RESULT
FOR TEMP_ID, 0, TEMP_NUM
	;문자장 판정
	SIF !STRLENS(TEMP_STR:TEMP_ID)
		CONTINUE
	;중복 판정
	SIF FINDELEMENT(STR_LIST, TEMP_STR:TEMP_ID, 0, STR_NUM, 1) != -1
		CONTINUE
	STR_LIST:STR_NUM '= TEMP_STR:TEMP_ID
	CNT_LIST:STR_NUM  = MATCH(TEMP_STR, TEMP_STR:TEMP_ID)
	STR_NUM ++
NEXT
RESULT = TEMP_RESULT

;----------------------------------------------------------------------------------------------------
;동행중의 인원수를 돌려주는 함수
;----------------------------------------------------------------------------------------------------
@동행인원수()
#FUNCTION
RETURNF (CHARANUM - 1) - CMATCH(CFLAG:동행 , 0, 1, CHARANUM)
;MASTER가 수에 들어가지 않기 때문에 CHARANUM - 1입니다

;----------------------------------------------------------------------------------------------------
;DAILY_EV0로부터 잘라
;주인의 MAP의 YOGORE 관련 판정
;염려 사항：무명 지점의 YOGORE의 취급은 어떻게는 이겠지?
;----------------------------------------------------------------------------------------------------
;거점 맵의 더러움의 합계치를 돌려준다
@SUM_ALL_YOGORE()
#FUNCTION
RETURNF SUMARRAY(YOGORE, MINROOM(), MAXROOM)

;거점 맵의 더러움의 평균치를 돌려준다
@AVERAGE_YOGORE()
#FUNCTION
RETURNF SUM_ALL_YOGORE() / ROOM_NUM()

;거점 맵에 존재하는 지점의 수를 돌려준다
;무명 지점을 고려하고 있지 않는 점에 주의
@ROOM_NUM()
#FUNCTION
RETURNF MAXROOM % 100


;----------------------------------------------------------------------------------------------------
;메시지 첨부로 아이템/엔/카리스마를 입수하거나 지불하거나 하는 함수
;우선 정의 수만큼
;----------------------------------------------------------------------------------------------------
@GET_ITEM(ITEM_NAME, ITEM_NUM, PRINT_TYPE)
#DIMS ITEM_NAME
#DIM ITEM_ID
#DIM ITEM_NUM
#DIM PRINT_TYPE;표시형식　0=통상　1=L　2=W

ITEM_ID = GETNUM(ITEM, ITEM_NAME)
IF ITEM_ID == -1
	PRINTFORML %ITEM_NAME%가 존재하지 않습니다
ENDIF
DEBUGPRINTFORML %ITEM_NAME%를 취득、ID는 {ITEM_ID}
IF ITEM:ITEM_ID + ITEM_NUM >= 소지수제한 + 1 && 0 ;소지수제한 없앰
	CALL COLORMESSAGE(@"%조사처리(ITEMNAME:ITEM_ID,"를")% 더이상 가질 수 없다", C_YELLOW, PRINT_TYPE)
	ITEM:ITEM_ID = MAX(ITEM:ITEM_ID, 소지수제한)
ELSE
	CALL COLORMESSAGE(@"%조사처리(ITEMNAME:ITEM_ID,"를")% {ITEM_NUM}개 손에 넣었다", C_YELLOW, PRINT_TYPE)
	ITEM:ITEM_ID += ITEM_NUM
ENDIF

@LOST_ITEM(ITEM_NAME, ITEM_NUM, PRINT_TYPE)
#DIMS ITEM_NAME
#DIM ITEM_ID
#DIM ITEM_NUM
#DIM PRINT_TYPE;표시형식　0=통상　1=L　2=W

ITEM_ID = GETNUM(ITEM, ITEM_NAME)

SIF ITEM:ITEM_ID <= 0
	RETURN
CALL COLORMESSAGE(@"%조사처리(ITEMNAME:ITEM_ID,"를")% {ITEM_NUM}개 잃었다", C_YELLOW, PRINT_TYPE)
ITEM:ITEM_ID = MAX(ITEM:ITEM_ID - ITEM_NUM, 0)

@GET_MONEY_YEN(VALUE, PRINT_TYPE)
#DIM VALUE
#DIM PRINT_TYPE;표시형식　0=통상　1=L　2=W
SIF VALUE <= 0
	RETURN
CALL COLORMESSAGE(@"\\{VALUE}을 손에 넣었다", C_YELLOW, PRINT_TYPE)
MONEY += VALUE

@GET_SPELL_CARD_BONUS_YEN(VALUE, PRINT_TYPE)
#DIM VALUE
#DIM PRINT_TYPE;表示形式　0=通常　1=L　2=W
SIF VALUE <= 0
	RETURN
CALL COLORMESSAGE(@"GET ", 0xFFFFFF, 0)
CALL COLORMESSAGE(@"SpEll ", 0xC8FFFF, 0)
CALL COLORMESSAGE(@"CARd ", 0x64FFDC, 0)
CALL COLORMESSAGE(@"BONUS!!", 0x00FFB4, 1)
CALL COLORMESSAGE(@"        \\{VALUE}", C_YELLOW, PRINT_TYPE)
MONEY += VALUE

@GET_MONEY_CM(VALUE, PRINT_TYPE)
#DIM VALUE
#DIM PRINT_TYPE;표시형식　0=통상　1=L　2=W
SIF VALUE <= 0
	RETURN
CALL COLORMESSAGE(@"{VALUE}카리스마를 손에 넣었다", C_YELLOW, PRINT_TYPE)
MONEY:2 += VALUE

@LOST_MONEY_YEN(VALUE, PRINT_TYPE)
#DIM VALUE
#DIM PRINT_TYPE;표시형식　0=통상　1=L　2=W
SIF VALUE <= 0
	RETURN
CALL COLORMESSAGE(@"\\{VALUE}을 잃었다", C_YELLOW, PRINT_TYPE)
MONEY = MAX(0, MONEY - VALUE)

@LOST_MONEY_CM(VALUE, PRINT_TYPE)
#DIM VALUE
#DIM PRINT_TYPE;표시형식　0=통상　1=L　2=W
SIF VALUE <= 0
	RETURN
CALL COLORMESSAGE(@"{VALUE}카리스마를 잃었다", C_YELLOW, PRINT_TYPE)
MONEY:2 = MAX(0, MONEY:2 - VALUE)

@PAY_MONEY_YEN(VALUE, PRINT_TYPE)
#DIM VALUE
#DIM PRINT_TYPE;표시형식　0=통상　1=L　2=W
SIF VALUE <= 0
	RETURN
CALL COLORMESSAGE(@"\\{VALUE}를 지불했다", C_YELLOW, PRINT_TYPE)
MONEY = MAX(0, MONEY - VALUE)

@PAY_MONEY_CM(VALUE, PRINT_TYPE)
#DIM VALUE
#DIM PRINT_TYPE;표시형식　0=통상　1=L　2=W
SIF VALUE <= 0
	RETURN
CALL COLORMESSAGE(@"{VALUE}카리스마를 지불했다", C_YELLOW, PRINT_TYPE)
MONEY:2 = MAX(0, MONEY:2 - VALUE)

;캐릭터번호 C_ID의 ABL를 Avalue 변화시킨다
@ChangeABL(C_ID, Aname, Avalue)
#DIM C_ID
#DIM A_ID
#DIMS Aname
#DIM Avalue

A_ID = FINDELEMENT(ABLNAME, Aname)
ABL:C_ID:A_ID += Avalue
CALL COLORMESSAGE(@"%CALLNAME:C_ID%의 %조사처리(Aname,"가")% {ABL:C_ID:A_ID}로 \@ Avalue > 0 ? 올랐다 # 내렸다 \@",C_YELLOW,2)
;----------------------------------------------------------------------------------------------
; Author: えにゅあら
; Licensed by: CC0
; L_SEEDの値が同じなら同じ結果を返す疑似乱数（ノイズ関数）
; 0～L_SCALEの数値を返す（L_SCALEは含まない）
; L_SCALEの最大値は多分8589934592　計算の都合上これ以上を指定しても切り捨てられるはず
;----------------------------------------------------------------------------------------------
@NOISE(L_SEED, L_SCALE)
#FUNCTION
#DIM L_SEED
#DIM L_VAL
#DIM L_SCALE
; 適当にgoogleでランダム生成した数値をシードの初期位置にした。これやらないと0付近に全然ランダム感が出ない気がする
L_SEED = L_SEED ^ 0x145579EC
L_VAL = (L_SEED >> 13) ^ L_SEED
L_VAL = (L_VAL * (L_VAL * L_VAL * 60493 + 19990303) + 1376312589) & 0x7fffffff
RETURNF L_VAL * L_SCALE / 0x80000000


; ノイズを二つ加算したものを返す。平均値付近の値が出やすい。出現分布はきれいな三角形。
@NOISE2(L_SEED, L_SCALE)
#FUNCTION
#DIM L_SCALE
#DIM L_SCALE2
#DIM L_SEED
L_SCALE2 = L_SCALE / 2
L_SCALE = L_SCALE - L_SCALE2
RETURNF NOISE(L_SEED, L_SCALE) + NOISE(L_SEED ^ 0x1D47E2A3, L_SCALE2)


; ノイズを三つ加算したものを返す。平均値付近の値がとても出やすい。出現分布は山なりの曲線(正規分布)。
@NOISE3(L_SEED, L_SCALE)
#FUNCTION
#DIM L_SCALE
#DIM L_SCALE2
#DIM L_SEED
L_SCALE2 = L_SCALE / 3
L_SCALE = L_SCALE - L_SCALE2*2
RETURNF NOISE(L_SEED, L_SCALE) + NOISE(L_SEED ^ 0xFA7B7E26, L_SCALE2) + NOISE(L_SEED ^ 0x1D47E2A3, L_SCALE2)

;４つ以上加算しても３つ版と分布の形状は変わらず、単に平均値を中心に縮小されたものになるので、省く



; 使えそうか試しに表示してみる
@TEST_PRINTNOISE()
#FUNCTION
PRINTL NOISE1
FOR LOCAL, 0, 100
	PRINTFORML {NOISE(LOCAL, 100)}
NEXT
PRINTL NOISE2
FOR LOCAL, 0, 100
	PRINTFORML {NOISE2(LOCAL, 100)}
NEXT
PRINTL NOISE3
FOR LOCAL, 0, 100
	PRINTFORML {NOISE3(LOCAL, 100)}
NEXT

;단위 포함 3자리마다 콤마 표시(함수명은 임시)
@금액표시(ARG)
#FUNCTIONS
RETURNF MONEYSTR(ARG, "#,##0")

@세자리구분(ARG)
#FUNCTIONS
RETURNF TOSTR(ARG, "#,##0")

@세는법(ITEM_NO, ITEM_NUM = 1)
#FUNCTIONS
#DIM ITEM_NO
#DIM ITEM_NUM
SELECTCASE ITEM_NO
	CASE 627
		RETURNF "병"
	CASE 706
		RETURNF "마리"
	CASE 707, 708
		RETURNF "마리"
	CASEELSE
		RETURNF \@ ITEM_NUM < 10 ? 개 # 개 \@
ENDSELECT

@IS_LOVER(ARG)
#FUNCTION
SIF TALENT:ARG:연모
	RETURNF 1
SIF TALENT:ARG:애욕
	RETURNF 1
RETURNF 0

;-------------------------------------------
;함락상태의 지정;KR판 구잔재 ;일판에선 현재 사토리 커맨드자동신음 안에 있음
;ARG를 입력하지 않으면, TARGET 입력
;-------------------------------------------
@함락상태(ARG)
#FUNCTION
SIF !ARG
	ARG = TARGET
IF TALENT:ARG:연인
	IF CFLAG:깨끗한교제 && ((GETBIT (CFLAG:ARG:1490, 6) && ARG == 49) || ARG != 49)
		RETURNF 5
	ELSE
		RETURNF 4
	ENDIF
ELSEIF TALENT:ARG:연모 || TALENT:ARG:184 || TALENT:ARG:185
	RETURNF 3
ELSEIF (ARG == 49 && GETBIT (CFLAG:ARG:1490, 0)) || ((GETBIT (CFLAG:ARG:1 , 0) && ARG == 61))
	RETURNF 2
ELSEIF ((GETBIT (CFLAG:ARG:1 , 0) && ARG != 61) || TALENT:ARG:사모) && ((!GETBIT (CFLAG:ARG:1490, 1) && ARG == 49) || ARG != 49)
	RETURNF 1
ENDIF

@CHARASORT_EX
VARSET RESULT, -1
RESULT:0 = MASTER
RESULT:1 = [[레이무]]
RESULT:2 = [[마리사]]
RESULT:3 = [[루미아]]
RESULT:4 = [[대요정]]
RESULT:5 = [[치르노]]
RESULT:6 = [[메이링]]
RESULT:7 = [[소악마]]
RESULT:8 = [[파츄리]]
RESULT:9 = [[사쿠야]]
RESULT:10 = [[레밀리아]]
RESULT:11 = [[플랑]]
RESULT:12 = [[레티]]
RESULT:13 = [[첸]]
RESULT:14 = [[앨리스]]
RESULT:15 = [[릴리 W]]
RESULT:16 = [[릴리 B]]
RESULT:17 = [[리리카]]
RESULT:18 = [[메를랑]]
RESULT:19 = [[루나사]]
RESULT:20 = [[요우무]]
RESULT:21 = [[유유코]]
RESULT:22 = [[란]]
RESULT:23 = [[유카리]]
RESULT:24 = [[스이카]]
RESULT:25 = [[리글]]
RESULT:26 = [[미스티아]]
RESULT:27 = [[케이네]]
RESULT:28 = [[테위]]
RESULT:29 = [[우동게]]
RESULT:30 = [[에이린]]
RESULT:31 = [[카구야]]
RESULT:32 = [[모코우]]
RESULT:33 = [[아야]]
RESULT:34 = [[메디슨]]
RESULT:35 = [[유카]]
RESULT:36 = [[코마치]]
RESULT:37 = [[에이키]]
RESULT:38 = [[시즈하]]
RESULT:39 = [[미노리코]]
RESULT:40 = [[히나]]
RESULT:41 = [[니토리]]
RESULT:42 = [[모미지]]
RESULT:43 = [[사나에]]
RESULT:44 = [[카나코]]
RESULT:45 = [[스와코]]
RESULT:46 = [[서니]]
RESULT:47 = [[루나]]
RESULT:48 = [[스타]]
RESULT:49 = [[아큐]]
RESULT:50 = [[렌코]]
RESULT:51 = [[메리]]
RESULT:52 = [[이쿠]]
RESULT:53 = [[텐시]]
RESULT:54 = [[토요히메]]
RESULT:55 = [[요리히메]]
RESULT:56 = [[레이센]]
RESULT:57 = [[키스메]]
RESULT:58 = [[야마메]]
RESULT:59 = [[파르시]]
RESULT:60 = [[유기]]
RESULT:61 = [[사토리]]
RESULT:62 = [[오린]]
RESULT:63 = [[오쿠]]
RESULT:64 = [[코이시]]
RESULT:65 = [[토키코]]
RESULT:66 = [[나즈린]]
RESULT:67 = [[코가사]]
RESULT:68 = [[이치린]]
RESULT:69 = [[무라사]]
RESULT:70 = [[쇼]]
RESULT:71 = [[뱌쿠렌]]
RESULT:72 = [[누에]]
RESULT:73 = [[하타테]]
RESULT:74 = [[카센]]
RESULT:75 = [[쿄코]]
RESULT:76 = [[요시카]]
RESULT:77 = [[청아]]
RESULT:78 = [[토지코]]
RESULT:79 = [[후토]]
RESULT:80 = [[미코]]
RESULT:81 = [[마미조]]
RESULT:82 = [[코스즈]]
RESULT:83 = [[코코로]]
RESULT:84 = [[와카사기히메]]
RESULT:85 = [[반키]]
RESULT:86 = [[카게로]]
RESULT:87 = [[벤벤]]
RESULT:88 = [[야츠하시]]
RESULT:89 = [[세이자]]
RESULT:90 = [[신묘마루]]
RESULT:91 = [[라이코]]
RESULT:92 = [[스미레코]]
RESULT:93 = [[세이란]]
RESULT:94 = [[링고]]
RESULT:95 = [[도레미]]
RESULT:96 = [[사구메]]
RESULT:97 = [[클라운피스]]
RESULT:98 = [[순호]]
RESULT:99 = [[헤카티아]]
RESULT:100 = [[라바]]
RESULT:101 = [[네무노]]
RESULT:102 = [[아운]]
RESULT:103 = [[나루미]]
RESULT:104 = [[마이]]
RESULT:105 = [[사토노]]
RESULT:106 = [[오키나]]
RESULT:107 = [[조온]]
RESULT:108 = [[시온]]
RESULT:109 = [[에이카]]
RESULT:110 = [[우루미]]
RESULT:111 = [[쿠타카]]
RESULT:112 = [[야치에]]
RESULT:113 = [[마유미]]
RESULT:114 = [[케이키]]
RESULT:115 = [[사키]]
RESULT:116 = [[미요이]]
RESULT:117 = [[미케]]
RESULT:118 = [[타카네]]
RESULT:119 = [[코마쿠사]]
RESULT:120 = [[미스마루]]
RESULT:121 = [[츠카사]]
RESULT:122 = [[메구무]]
RESULT:123 = [[치마타]]
RESULT:124 = [[모모요]]
RESULT:125 = [[유마]]

RESULT:201 = [[미마]]
RESULT:202 = [[리카]]
RESULT:203 = [[메이라]]
RESULT:204 = [[엘렌]]
RESULT:205 = [[카나]]
RESULT:206 = [[리카코]]
RESULT:207 = [[치유리]]
RESULT:208 = [[유메미]]
RESULT:209 = [[루코토]]
RESULT:210 = [[쿠루미]]
RESULT:211 = [[엘리]]
RESULT:212 = [[무게츠]]
RESULT:213 = [[겐게츠]]
RESULT:214 = [[루이즈]]
RESULT:215 = [[유키]]
RESULT:216 = [[마이]]
RESULT:217 = [[유메코]]
RESULT:218 = [[신키]]

RESULT:299 = [[모브코]]
